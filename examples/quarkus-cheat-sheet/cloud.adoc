== Cloud

*Native*

You can build a native image by using GraalVM.
The common use case is creating a Docker image so you can execute the next commands:

[source, bash]
----
./mvnw package -Pnative -Dquarkus.native.container-build=true

docker build -f src/main/docker/Dockerfile.native 
                    -t quarkus/getting-started .
docker run -i --rm -p 8080:8080 quarkus/getting-started
----

// tag::update_11_6[]
You can use `quarkus.native.container-runtime` to select the container runtime to use.
Now `docker` (default) and `podman` are the valid options.

[source, bash]
----
./mvnw package -Pnative -Dquarkus.native.container-runtime=podman
----
// end::update_11_6[]

// tag::update_1_6[]
To configure native application, you can create a `config` directory at the same place as the native file and place an `application.properties` file inside. `config/application.properties`.
// end::update_1_6[]

*Kubernetes*

Quarks can use https://github.com/dekorateio/dekorate[Dekorate] to generate Kubernetes resources.

[source, bash]
----
./mvnw quarkus:add-extensions 
    -Dextensions="io.quarkus:quarkus-kubernetes"
----

Running `./mvnw package` the Kubernetes resources are created at `target/kubernetes/` directory.

|===	
| Property | Default | Description

a|`kubernetes.group`
a|Current username
a|Set Docker Username.

a|`quarkus.application.name`
a|Current project name
a|Project name
|===

Generated resource is integrated with <<Observability, MicroProfile Health annotations>>.

// tag::update_11_3[]
Also, you can customize the generated resource by setting the new values in `application.properties`:

[source, properties]
----
kubernetes.replicas=3

kubernetes.labels[0].key=foo
kubernetes.labels[0].value=bar

kubernetes.readiness-probe.period-seconds=45

docker.registry=quay.io
----

All possible values are explained at https://quarkus.io/guides/kubernetes#configuration-options.
// end::update_11_3[]

*Kubernetes Deployment Targets*
// tag::update_12_4[]

You can generate different resources setting the property `kubernetes.deployment.target`.

Possible values are `kubernetes`, `openshift` and `knative`.
The default value is `kubernetes`.
// end::update_12_4[]

== Kubernetes Client
// tag::update_4_5[]
Quarkus integrates with https://github.com/fabric8io/kubernetes-client[Fabric8 Kubernetes Client, window="_blank"].

[source, terminal]
----
./mvnw quarkus:add-extension 
    -Dextensions="quarkus-kubernetes-client"
----

// tag::update_6_5[]
List of Kubernetes client parameters.

`quarkus.kubernetes-client` as prefix is skipped in the next table.

|===	
| Property | Default | Description

a|`trust-certs`
a|`false`
|Trust self-signed certificates.

a|`master-url`
a|
|URL of Kubernetes API server.

a|`namesapce`
a|
|Default namespace.

a|`ca-cert-file`
a|
|CA certificate data.

a|`client-cert-file`
a|
|Client certificate file.

a|`client-cert-data`
a|
|Client certificate data.

a|`client-key-data`
a|
|Client key data.

a|`client-key-algorithm`
a|
|Client key algorithm.

a|`client-key-passphrase`
a|
|Client key passphrase.

a|`username`
a|
|Username.

a|`password`
a|
|Password.

a|`watch-reconnect-interval`
a|`PT1S`
|Watch reconnect interval.

a|`watch-reconnect-limit`
a|`-1`
|Maximum reconnect attempts.

a|`connection-timeout`
a|`PT10S`
|Maximum amount of time to wait for a connection.

a|`request-timeout`
a|`PT10S`
|Maximum amount of time to wait for a request.

a|`rolling-timeout`
a|`PT15M`
|Maximum amount of time to wait for a rollout.

a|`http-proxy`
a|
|HTTP proxy used to access the Kubernetes.

a|`https-proxy`
a|``
|HTTPS proxy used to access the Kubernetes.

a|`proxy-username`
a|
|Proxy username.

a|`proxy-password`
a|
|Proxy password.

a|`no-proxy`
a|
|IP addresses or hosts to exclude from proxying
|===
// end::update_6_5[]

Or programmatically:

[source, java]
----
@Dependent
public class KubernetesClientProducer {

    @Produces
    public KubernetesClient kubernetesClient() {
        Config config = new ConfigBuilder()
            .withMasterUrl("https://mymaster.com")
            .build();
        return new DefaultKubernetesClient(config);
    }
}
----

And inject it on code:

[source, java]
----
@Inject
KubernetesClient client;

ServiceList myServices = client.services().list();

Service myservice = client.services()
        .inNamespace("default")
        .withName("myservice")
        .get();

CustomResourceDefinitionList crds = client
        .customResourceDefinitions()
        .list();

dummyCRD = new CustomResourceDefinitionBuilder()
        ...
        .build()
client.customResourceDefinitions()
        .create(dummyCRD);
----
// end::update_4_5[]

*Testing*

// tag::update_5_9[]
Quarkus provides a Kubernetes Mock test resource that starts a mock of Kubernetes API server and sets the proper environment variables needed by Kubernetes Client.

Register next dependency: `io.quarkus:quarkus-test-kubernetes-client:test`.

[source, java]
----
@QuarkusTestResource(KubernetesMockServerTestResource.class)
@QuarkusTest
public class KubernetesClientTest {
    
    @MockServer
    private KubernetesMockServer mockServer;

    @Test
    public void test() {
        final Pod pod1 = ...
        mockServer
            .expect()
            .get()
            .withPath("/api/v1/namespaces/test/pods")
            .andReturn(200,
                new PodListBuilder()
                .withNewMetadata()
                .withResourceVersion("1")
                .endMetadata()
                .withItems(pod1, pod2)
                .build())
            .always();
    }
}
----
// end::update_5_9[]

== Amazon Lambda
// tag::update_1_10[]
Quarkus integrates with Amazon Lambda.

[source, bash]
----
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-amazon-lambda"
----

And then implement `com.amazonaws.services.lambda.runtime.RequestHandler` interface.

[source, java]
----
public class TestLambda 
        implements RequestHandler<MyInput, MyOutput> {
    @Override
    public MyInput handleRequest(MyOutput input, 
                                    Context context) {
    }
}
----

// tag::update_9_4[]
You can set the handler name by using `quarkus.lambda.handler` property or by annotating the Lambda with the CDI `@Named` annotation.
// end::update_9_4[]

*Test*

You can write tests for Amazon lambdas:

[source, xml]
----
<dependency>
  <groupId>io.quarkus</groupId>
  <artifactId>quarkus-test-amazon-lambda</artifactId>
  <scope>test</scope>
</dependency>
----

[source, java]
----
@Test
public void testLambda() {
    MyInput in = new MyInput();
    in.setGreeting("Hello");
    in.setName("Stu");
    MyOutput out = LambdaClient.invoke(MyOutput.class, in);
}
----
// end::update_1_10[]

// tag::update_11_8[]
To scaffold a AWS Lambda run:

[source, bash]
----
mvn archetype:generate \
    -DarchetypeGroupId=io.quarkus \
    -DarchetypeArtifactId=quarkus-amazon-lambda-archetype \
    -DarchetypeVersion={version}
----
// end::update_11_8[]

== Azure Functions

// tag::update_8_6[]
Quarkus can make a microservice be deployable to the Azure Functions.

To scaffold a deployable microservice to the Azure Functions run:

[source, bash]
----
mvn archetype:generate \
  -DarchetypeGroupId=io.quarkus \
  -DarchetypeArtifactId=quarkus-azure-functions-http-archetype \
  -DarchetypeVersion={version}
----
// end::update_8_6[]