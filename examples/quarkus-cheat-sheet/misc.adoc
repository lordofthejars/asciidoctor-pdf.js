== Apache Camel
// tag::update_2_1[]
Apache Camel Quarkus has its own site: https://github.com/apache/camel-quarkus
// end::update_2_1[]

== WebSockets
// tag::update_2_2[]
Quarkus can be used to handling web sockets.

[source, bash]
----
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-undertow-websockets"
----

And web sockets classes can be used:

[source, java]
----
@ServerEndpoint("/chat/{username}")
@ApplicationScoped
public class ChatSocket {

    @OnOpen
    public void onOpen(Session session, 
                @PathParam("username") String username) {}

    @OnClose
    public void onClose(..) {}

    @OnError
    public void onError(..., Throwable throwable) {}

    @OnMessage
    public void onMessage(...) {}

}
----
// end::update_2_2[]

== OpenAPI
// tag::update_2_3[]
Quarkus can expose its API description as https://swagger.io/specification/[OpenAPI, window="_blank"] spec and test it using https://swagger.io/tools/swagger-ui/[Swagger UI, window="_blank"].

[source, bash]
----
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-smallrye-openapi"
----

Then you only need to access to `/openapi` to get OpenAPI v3 spec of services.

// tag::update_3_5[]
You can update the OpenApi path by setting `quarkus.smallrye-openapi.path` property.
// end::update_3_5[]

Also, in case of starting Quarkus application in `dev` or `test` mode, Swagger UI is accessible at `/swagger-ui`.
If you want to use it in production mode you need to set `quarkus.swagger-ui.always-include` property to `true`.

You can update the Swagger UI path by setting `quarkus.swagger-ui.path` property.

[source, properties]
----
quarkus.swagger-ui.path=/my-custom-path
----
// end::update_2_3[]

// tag::update_6_6[]
You can customize the output by using Open API v3 annotations.

[source, java]
----
@Schema(name="Developers", 
        description="POJO that represents a developer.")
public class Developer {
    @Schema(required = true, example = "Alex")
    private String name;
}

@POST
@Path("/developer")
@Operation(summary = "Create deeloper",
           description = "Only be done by admin.")
public Response createDeveloper(
        @RequestBody(description = "Developer object", 
            required = true,
            content = @Content(schema = 
            @Schema(implementation = Developer.class))) 
                Developer developer)
----

All possible annotations can be seen at https://github.com/eclipse/microprofile-open-api/tree/master/api/src/main/java/org/eclipse/microprofile/openapi/annotations[org.eclipse.microprofile.openapi.annotations, window="_blank"] package.
// end::update_6_6[]

// tag::update_8_10[]
You can also serve OpenAPI Schema from static files instead of dynamically generated from annotation scanning.

You need to put OpenAPIdocumentation under `META-INF` directory (ie: `META-INF/openapi.yaml`).

A request to `/openapi` will serve the combined OpenAPI document from the static file and the generated from annotations.
You can disable the scanning documents by adding the next configuration property: `mp.openapi.scan.disable=true`.

Other valid document paths are: `META-INF/openapi.yml`, `META-INF/openapi.json`, `WEB-INF/classes/META-INF/openapi.yml`, `WEB-INF/classes/META-INF/openapi.yaml`, `WEB-INF/classes/META-INF/openapi.json`.
// end::update_8_10[]

== Mail Sender
// tag::update_2_5[]
You can send emails by using Quarkus Mailer extension:

[source, bash]
----
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-mailer"
----

You can inject two possible classes `io.quarkus.mailer.Mailer` for synchronous API or `io.quarkus.mailer.ReactiveMailer` for asynchronous API.

[source, java]
----
@Inject
Mailer mailer;

@Inject
ReactiveMailer reactiveMailer;
----

And then you can use them to send an email:

[source, java]
----
mailer.send(
    Mail.withText("to@acme.org", "Subject", "Body")
);

CompletionStage<Void> stage = 
    reactiveMailer.send(
        Mail.withText("to@acme.org", "Subject", "Body")
    );
----

`Mail` class contains methods to add `cc`, `bcc`, `headers`, `bounce address`, `reply to`, `attachments`, `inline attachments` and `html body`.

[source, java]
----
mailer.send(Mail.withHtml("to@acme.org", "Subject", body)
      .addInlineAttachment("quarkus.png",
            new File("quarkus.png"),
            "image/png", "<my-image@quarkus.io>"));
----

TIP: If you need deep control you can inject Vert.x mail client `@Inject  MailClient client;`

You need to configure SMTP properties to be able to send an email:

[source, properties]
----
quarkus.mailer.from=test@quarkus.io
quarkus.mailer.host=smtp.sendgrid.net
quarkus.mailer.port=465
quarkus.mailer.ssl=true
quarkus.mailer.username=....
quarkus.mailer.password=....
----

List of Mailer parameters.
`quarkus.` as a prefix is skipped in the next table.

<<<

|===	
|Parameter | Default | Description

a|`mailer.from`
|
a|Default address.

a|`mailer.mock`
a|false in `prod`, true in `dev` and `test`.
|Emails not sent, just printed and stored in a `MockMailbox`.

a|`mailer.bounce-address`
|
|Default address.

a|`mailer.host`
a|_mandatory_
|SMTP host.

a|`mailer.port`
|25
|SMTP port.

a|`mailer.username`
|
|The username.

a|`mailer.password`
|
|The password.

a|`mailer.ssl`
a|`false`
|Enables SSL.

a|`mailer.trust-all`
|false
|Trust all certificates.

a|`mailer.max-pool-size`
|10
|Max open connections .

a|`mailer.own-host-name`
|
a|Hostname for `HELO/EHLO` and `Message-ID`

a|`mailer.keep-alive`
a|`true`
|Connection pool enabled.

a|`mailer.disable-esmtp`
a|`false`
|Disable ESMTP.

a|`mailer.start-tls`
a|`OPTIONAL`
a|TLS security mode. `DISABLED`, `OPTIONAL`, `REQUIRED`.

a|`mailer.login`
a|`NONE`
a|Login mode. `NONE`, `OPTIONAL`, `REQUIRED`.

a|`mailer.auth-methods`
|All methods.
|Space-separated list.

a|`mailer.key-store`
|
|Path of the key store.

a|`mailer.key-store-password`
|
|Key store password.
|===
// tag::update_3_7[]
// tag::update_6_x[]
*IMPORTANT:*  if you enable SSL for the mailer and you want to build a native executable, you will need to enable the SSL support `quarkus.ssl.native=true`. 
// end::update_6_x[]

*Testing*

If `quarkus.mailer.mock` is set to `true`, which is the default value in `dev` and `test` mode, you can inject `MockMailbox` to get the sent messages.

[source, java]
----
@Inject
MockMailbox mailbox;

@BeforeEach
void init() {
    mailbox.clear();
}

List<Mail> sent = mailbox
                    .getMessagesSentTo("to@acme.org");
----
// end::update_3_7[]

// end::update_2_5[]

== Scheduled Tasks
// tag::update_3_2[]
You can schedule periodic tasks with Quarkus.

[source, java]
----
@ApplicationScoped
public class CounterBean {

    @Scheduled(every="10s")
    void increment() {}

    @Scheduled(cron="0 15 10 * * ?")
    void morningTask() {}
}
----

`every` and `cron` parameters can be surrounded with `{}` and the value is used as config property to get the value. 

[source java]
----
@Scheduled(cron = "{morning.check.cron.expr}")
void morningTask() {}
----

And configure the property into `application.properties`:

[source, properties]
----
morning.check.cron.expr=0 15 10 * * ?
----
// end::update_3_2[]

== Kogito
// tag::update_3_9[]
Quarkus integrates with http://www.kiegroup.org/[Kogito, window="_blank"], a next-generation business automation toolkit from Drools and jBPM projects for adding business automation capabilities.

To start using it you only need to add the next extension:

[source, bash]
----
./mvnw quarkus:add-extension 
  -Dextensions="kogito"
----
// end::update_3_9[]

<<<

== Apache Tika
// tag::update_5_8[]

Quarkus integrets with https://tika.apache.org/[Apache Tika, window="_blank"] to detect and extract metadata/text from different file types:

[source, bash]
----
./mvnw quarkus:add-extension 
  -Dextensions="quarkus-tika"
----

[source, java]
----
@Inject
io.quarkus.tika.TikaParser parser;

@POST
@Path("/text")
@Consumes({ "text/plain", "application/pdf", 
            "application/vnd.oasis.opendocument.text" })
@Produces(MediaType.TEXT_PLAIN)
public String extractText(InputStream stream) {
    return parser.parse(stream).getText();
}
----

// tag::update_7_3[]
You can configure Apache Tika in `application.properties` file by using next properties prefixed with `quarkus`:

|===	
|Parameter | Default | Description

a|`tika.tika-config-path`
a|`tika-config.xml`
a|Path to the Tika configuration resource. 

a|`quarkus.tika.parsers`
a|
a|CSV of the abbreviated or full parser class to be loaded by the extension.

a|`tika.append-embedded-content`
a|`true`
a|The document may have other embedded documents. Set if autmatically append.
|===
// end::update_7_3[]
// end::update_5_8[]

== JGit
// tag::update_8_1[]

Quarkus integrets with https://www.eclipse.org/jgit/[JGit, window="_blank"] to integrate with Git repositories:

[source, bash]
----
./mvnw quarkus:add-extension 
  -Dextensions="quarkus-jgit"
----

And then you can start using JGit:

[source, java]
----
try (Git git = Git.cloneRepository()
                  .setDirectory(tmpDir)
                  .setURI(url)
                  .call()) {
    return tmpDir.toString();
}
----

*IMPORTANT:* When running in native mode, make sure to configure SSL access correctly `quarkus.ssl.native=true` (https://quarkus.io/guides/native-and-ssl-guide[Native and SSL, window="_blank"]). 
// end::update_8_1[]

== Web Resources
// tag::update_8_9[]

You can serve web resources with Quarkus.
You need to place web resources at `src/main/resources/META-INF/resources` and then they are accessible (ie http://localhost:8080/index.html)
// end::update_8_9[]