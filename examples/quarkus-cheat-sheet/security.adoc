== JWT
// tag::update_1_5[]
Quarkus implements https://github.com/eclipse/microprofile-jwt-auth[MicroProfile JWT RBAC spec, window="_blank"].

[source, bash]
----
mvn quarkus:add-extension 
    -Dextensions="io.quarkus:quarkus-smallrye-jwt"
----

Minimum JWT required claims: `typ`, `alg`, `kid`, `iss`, `sub`, `exp`, `iat`, `jti`, `upn`, `groups`.

You can inject token by using `JsonWebToken` or a claim individually by using `@Claim`.

[source, java]
----
@Inject
JsonWebToken jwt;

@Inject
@Claim(standard = Claims.preferred_username)
String name;

@Inject
@Claim("groups")
Set<String> groups;
----

Set of supported types: `String`, `Set<String>`, `Long`, `Boolean, `javax.json.JsonValue`, `Optional`, `org.eclipse.microprofile.jwt.ClaimValue`.

And configuration in `src/main/resources/application.properties`:

[source, properties]
----
mp.jwt.verify.publickey.location=
    META-INF/resources/publicKey.pem
mp.jwt.verify.issuer=
    https://quarkus.io/using-jwt-rbac
----

Configuration options:

|===	
| Parameter | Default | Description

a|`quarkus.smallrye-jwt.enabled`
a|`true`
|Determine if the jwt extension is enabled.

a|`quarkus.smallrye-jwt.realm-name`
|Quarkus-JWT
|Name to use for security realm.

a|`quarkus.smallrye-jwt.auth-mechanism`
|MP-JWT
|Authentication mechanism.

a|`mp.jwt.verify.publickey`
|none
|Public Key text itself to be supplied as a string.

a|`mp.jwt.verify.publickey.location`
|none
|Relative path or URL of a public key.

a|`mp.jwt.verify.issuer`
|none
a|`iss` accepted as valid.
|===

Supported public key formats:

* PKCS#8 PEM
* JWK
* JWKS
* JWK Base64 URL
* JWKS Base64 URL

To send a token to server-side you should use `Authorization` header: `curl -H "Authorization: Bearer eyJraWQiOi..."`.

To inject claim values, the bean must be `@RequestScoped` CDI scoped.
If you need to inject claim values in scope with a lifetime greater than `@RequestScoped` then you need to use `javax.enterprise.inject.Instance` interface.

[source, java]
----
@Inject
@Claim(standard = Claims.iat)
private Instance<Long> providerIAT;
----

*RBAC*

JWT `groups` claim is directly mapped to roles to be used in security annotations.

[source, java]
----
@RolesAllowed("Subscriber")
----
// end::update_1_5[]

== Open Id Connect
// tag::update_1_9[]
Quarkus can use OpenId Connect or OAuth 2.0 authorization servers such as  https://www.keycloak.org/[Keycloak, window="_blank"] to protect resources using bearer token issued by Keycloak server.

[source, bash]
----
mvn quarkus:add-extension 
    -Dextensions="using-openid-connect"
----

<<<

You can also protect resources with security annotations.

[source, java]
----
@GET
@RolesAllowed("admin")
----

Configure application to Keycloak service in `application.properties` file.

[source, properties]
----
quarkus.oidc.realm=quarkus
quarkus.oidc.auth-server-url=http://localhost:8180/auth
quarkus.oidc.resource=backend-service
quarkus.oidc.bearer-only=true
quarkus.oidc.credentials.secret=secret
----

Configuration options with `quarkus.oidc` prefix:

|===	
| Parameter | Default | Description

a|`auth-server-url`
a|
a|The base URL of the OpenID Connect (OIDC) server

a|`introspection-path`
a|
a|Relative path of the RFC7662 introspection service

a|`jwks-path`
a|
a|Relative path of the OIDC service returning a JWK set

a|`public-key`
a|
a|Public key for the local JWT token verification

a|`client-id`
a|
a|The client-id of the application.

a|`credentials.secret`
a|
a|The client secret
|===

*NOTE:*  With Keycloak OIDC server `https://host:port/auth/realms/{realm}` where `{realm}` has to be replaced by the name of the Keycloak realm.

*TIP:* You can use `quarkus.http.cors` property to enable consuming form different domain.
// end::update_1_9[]

== OAuth2
// tag::update_6_8[]
Quarkus integrates with OAuth2 to be used in case of opaque tokens (none JWT) and its validation against an introspection endpoint.

[source, bash]
----
mvn quarkus:add-extension 
    -Dextensions="security-oauth2"
----

And configuration in `src/main/resources/application.properties`:

[source, properties]
----
quarkus.oauth2.client-id=client_id
quarkus.oauth2.client-secret=secret
quarkus.oauth2.introspection-url=http://oauth-server/introspect
----

And you can map roles to be used in security annotations.

[source, java]
----
@RolesAllowed("Subscriber")
----

Configuration options:

|===	
| Parameter | Default | Description

a|`quarkus.oauth2.enabled`
a|`true`
|Determine if the OAuth2 extension is enabled.

a|`quarkus.oauth2.client-id`
a|
|The OAuth2 client id used to validate the token.

a|`quarkus.oauth2.client-secret`
a|
|The OAuth2 client secret used to validate the token.

a|`quarkus.oauth2.introspection-url`
a|
|URL used to validate the token and gather the authentication claims.

a|`quarkus.oauth2.role-claim`
a|`scope`
|The claim that is used in the endpoint response to load the roles
|===
// end::update_6_8[]

== Security with a JDBC Realm

// tag::update_9_7[]
You can also protect endpoints and store identities in a database.

[source, bash]
----
mvn quarkus:add-extension 
    -Dextensions="elytron-security-jdbc"
----

You still need to add the database driver (ie `jdbc-h2`).

You need to configure JDBC and Elytron JDBC Realm:

[source, properties]
----
quarkus.datasource.url=
quarkus.datasource.driver=org.h2.Driver
quarkus.datasource.username=sa
quarkus.datasource.password=sa

quarkus.security.jdbc.enabled=true
quarkus.security.jdbc.principal-query.sql=
    SELECT u.password, u.role FROM test_user u WHERE u.username=? 
quarkus.security.jdbc.principal-query.clear-password-mapper.enabled=true 
quarkus.security.jdbc.principal-query.clear-password-mapper.password-index=1
quarkus.security.jdbc.principal-query.attribute-mappings.0.index=2 
quarkus.security.jdbc.principal-query.attribute-mappings.0.to=groups
----

You need to set the index (1-based) of password and role.

Elytron JDBC Realm configuration properties.
Prefix `quarkus.security.jdbc` is skipped.

|===	
| Parameter | Default | Description

a|`auth-mechanism`
a|`BASIC`
|The authentication mechanism

a|`realm-name`
a|`Quarkus`
|The authentication mechanism

a|`enabled`
a|`false`
|If the properties store is enabled

a|`principal-query.sql`
a|
|The sql query to find the password

a|`principal-query.datasource`
a|
|The data source to use

a|`principal-query.clear-password-mapper.enabled`
a|`false`
|If the clear-password-mapper is enabled

a|`principal-query.clear-password-mapper.password-index`
a|`1`
|The index of column containing clear password

a|`principal-query.bcrypt-password-mapper.enabled`
a|`false`
|If the bcrypt-password-mapper is enabled

a|`principal-query.bcrypt-password-mapper.password-index`
a|`0`
|The index of column containing password hash

a|`principal-query.bcrypt-password-mapper.hash-encoding`
a|`BASE64`
|A string referencing the password hash encoding (`BASE64` or `HEX`)

a|`principal-query.bcrypt-password-mapper.salt-index`
a|`0`
|The index column containing the Bcrypt salt

a|`principal-query.bcrypt-password-mapper.salt-encoding`
a|`BASE64`
|A string referencing the salt encoding (`BASE64` or `HEX`)

a|`principal-query.bcrypt-password-mapper.iteration-count-index`
a|`0`
|The index column containing the Bcrypt iteration count
|===

For multiple datasources you can use the datasource name in the properties:

[source, properties]
----
quarkus.datasource.url=
quarkus.security.jdbc.principal-query.sql=

quarkus.datasource.permissions.url=
quarkus.security.jdbc.principal-query.permissions.sql=
----
// end::update_9_7[]