== RBAC

// tag::update_10_4[]

You can set RBAC using annotations or in `application.properties`.

*Annotations*

You can define roles by using `javax.annotation.security.RolesAllowed` annotation.

[source, java]
----
@RolesAllowed("Subscriber")
----

You can use `io.quarkus.security.Authenticated` as a shortcut of `@RolesAllowed("*")`.

// tag::update_11_2[]
To alter RBAC behaviour there are two configuration properties:

[source, properties]
----
quarkus.security.deny-unannotated=true
----

Configuration options:

|===	
| Parameter | Default | Description

a|`quarkus.jaxrs.deny-uncovered`
a|`false`
|If true denies by default to all JAX-RS endpoints.

a|`quarkus.security.deny-unannotated`
a|`false`
|If true denies by default all CDI methods and JAX-RS endpoints.
|===
// end::update_11_2[]

*File Configuration*

Defining RBAC in `application.properties` instead of using annotations.

[source, properties]
----
quarkus.http.auth.policy.role-policy1.roles-allowed=
    user,admin                      
quarkus.http.auth.permission.roles1.paths=
    /roles-secured/*,/other/*,/api/*          
quarkus.http.auth.permission.roles1.policy=
    role-policy1

quarkus.http.auth.permission.permit1.paths=
    /public/*                                
quarkus.http.auth.permission.permit1.policy=
    permit
quarkus.http.auth.permission.permit1.methods=
    GET

quarkus.http.auth.permission.deny1.paths=
    /forbidden                                 
quarkus.http.auth.permission.deny1.policy=
    deny
----

<<<

You need to provide permissions set by using the `roles-allowed` property or use the built-in ones `deny`, `permit` or `authenticated`. 
// end::update_10_4[]

== JWT
// tag::update_1_5[]
Quarkus implements https://github.com/eclipse/microprofile-jwt-auth[MicroProfile JWT RBAC spec, window="_blank"].

[source, bash]
----
mvn quarkus:add-extension 
    -Dextensions="io.quarkus:quarkus-smallrye-jwt"
----

Minimum JWT required claims: `typ`, `alg`, `kid`, `iss`, `sub`, `exp`, `iat`, `jti`, `upn`, `groups`.

You can inject token by using `JsonWebToken` or a claim individually by using `@Claim`.

[source, java]
----
@Inject
JsonWebToken jwt;

@Inject
@Claim(standard = Claims.preferred_username)
String name;

@Inject
@Claim("groups")
Set<String> groups;
----

Set of supported types: `String`, `Set<String>`, `Long`, `Boolean, `javax.json.JsonValue`, `Optional`, `org.eclipse.microprofile.jwt.ClaimValue`.

And configuration in `src/main/resources/application.properties`:

[source, properties]
----
mp.jwt.verify.publickey.location=
    META-INF/resources/publicKey.pem
mp.jwt.verify.issuer=
    https://quarkus.io/using-jwt-rbac
----

Configuration options:

`mp.jwt.verify.publickey`::
Public Key text itself to be supplied as a string.

`mp.jwt.verify.publickey.location`
Relative path or URL of a public key.

`mp.jwt.verify.issuer`::
`iss` accepted as valid.

// tag::update_13_16[]
`smallrye.jwt.token.header`::
Sets header such as `Cookie` is used to pass the token. (default: `Authorization`).

`smallrye.jwt.token.cookie`::
Name of the cookie containing a token.

`smallrye.jwt.token.schemes`::
Comma-separated list containing an alternative single or multiple schemes. (default: `Bearer`).

`smallrye.jwt.require.named-principal`::
A token must have a upn or preferred_username or sub claim set if using `java.security.Principal`. `True` makes throw an exception if not set. (default: `false`).

`smallrye.jwt.path.sub`::
Path to the claim with subject name.

`smallrye.jwt.claims.sub`::
Default sub claim value.

`smallrye.jwt.path.groups`::
Path to the claim containing the groups.

`smallrye.jwt.path.groups-separator`::
Separator for splitting a string which may contain multiple group values. (default. ` `).

`smallrye.jwt.claims.groups`::
Default groups claim value.

`smallrye.jwt.jwk.refresh-interval`::
JWK cache refresh interval in minutes. (default: `60`).

`smallrye.jwt.expiration.grace`::
Expiration grace in seconds. (default: `60`).

`smallrye.jwt.verify.audience`::
Comma separated list of the audiences that a token aud claim may contain.
// end::update_13_16[]

Supported public key formats:

* PKCS#8 PEM
* JWK
* JWKS
* JWK Base64 URL
* JWKS Base64 URL

To send a token to server-side you should use `Authorization` header: `curl -H "Authorization: Bearer eyJraWQiOi..."`.

To inject claim values, the bean must be `@RequestScoped` CDI scoped.
If you need to inject claim values in scope with a lifetime greater than `@RequestScoped` then you need to use `javax.enterprise.inject.Instance` interface.

[source, java]
----
@Inject
@Claim(standard = Claims.iat)
private Instance<Long> providerIAT;
----

*RBAC*

JWT `groups` claim is directly mapped to roles to be used in security annotations.

[source, java]
----
@RolesAllowed("Subscriber")
----
// end::update_1_5[]

*Generate tokens*

// tag::update_13_15[]
JWT generation API:

[source, java]
----
Jwt.claims()
    .issuer("https://server.com")
    .claim("customClaim", 3)
    .sign(createKey());

JwtSignatureBuilder jwtSignatureBuilder = Jwt.claims("/testJsonToken.json").jws();
jwtSignatureBuilder
     .signatureKeyId("some-key-id")
     .signatureAlgorithm(SignatureAlgorithm.ES256)
     .header("custom-header", "custom-value");    
     .sign(createKey());

Jwt.claims("/testJsonToken.json")
    .encrypt(createKey());

JwtEncryptionBuilder jwtEncryptionBuilder = Jwt.claims("/testJsonToken.json").jwe();
jwtEncryptionBuilder
     .keyEncryptionKeyId("some-key-id")
      .keyEncryptionAlgorithm(KeyEncryptionAlgorithm.ECDH_ES_A256KW)
     .header("custom-header", "custom-value");
     .encrypt(createKey());

Jwt.claims("/testJsonToken.json")
  .innerSign(createKey());
  .encrypt(createKey());
----
// end::update_13_15[]

== OpenId Connect
// tag::update_1_9[]
Quarkus can use OpenId Connect or OAuth 2.0 authorization servers such as  https://www.keycloak.org/[Keycloak, window="_blank"] to protect resources using bearer token issued by Keycloak server.

[source, bash]
----
mvn quarkus:add-extension 
    -Dextensions="using-openid-connect"
----

You can also protect resources with security annotations.

[source, java]
----
@GET
@RolesAllowed("admin")
----

Configure application to Keycloak service in `application.properties` file.

[source, properties]
----
quarkus.oidc.realm=quarkus
quarkus.oidc.auth-server-url=http://localhost:8180/auth
quarkus.oidc.resource=backend-service
quarkus.oidc.bearer-only=true
quarkus.oidc.credentials.secret=secret
----

Configuration options with `quarkus.oidc` prefix:

|===	
| Parameter | Default | Description

a|`auth-server-url`
a|
a|The base URL of the OpenID Connect (OIDC) server

a|`introspection-path`
a|
a|Relative path of the RFC7662 introspection service

a|`jwks-path`
a|
a|Relative path of the OIDC service returning a JWK set

a|`public-key`
a|
a|Public key for the local JWT token verification

a|`client-id`
a|
a|The client-id of the application.

a|`credentials.secret`
a|
a|The client secret
|===

NOTE:  With Keycloak OIDC server `https://host:port/auth/realms/{realm}` where `{realm}` has to be replaced by the name of the Keycloak realm.

TIP: You can use `quarkus.http.cors` property to enable consuming form different domain.
// end::update_1_9[]

== OAuth2
// tag::update_6_8[]
Quarkus integrates with OAuth2 to be used in case of opaque tokens (none JWT) and its validation against an introspection endpoint.

[source, bash]
----
mvn quarkus:add-extension 
    -Dextensions="security-oauth2"
----

And configuration in `src/main/resources/application.properties`:

[source, properties]
----
quarkus.oauth2.client-id=client_id
quarkus.oauth2.client-secret=secret
quarkus.oauth2.introspection-url=http://oauth-server/introspect
----

And you can map roles to be used in security annotations.

[source, java]
----
@RolesAllowed("Subscriber")
----

Configuration options:

|===	
| Parameter | Default | Description

a|`quarkus.oauth2.enabled`
a|`true`
|Determine if the OAuth2 extension is enabled.

a|`quarkus.oauth2.client-id`
a|
|The OAuth2 client id used to validate the token.

a|`quarkus.oauth2.client-secret`
a|
|The OAuth2 client secret used to validate the token.

a|`quarkus.oauth2.introspection-url`
a|
|URL used to validate the token and gather the authentication claims.

a|`quarkus.oauth2.role-claim`
a|`scope`
|The claim that is used in the endpoint response to load the roles
|===
// end::update_6_8[]

== Authenticating via HTTP

// tag::update_10_3[]
HTTP basic auth is enabled by the `quarkus.http.auth.basic=true` property.
// end::update_10_3[]

// tag::update_11_1[]
HTTP form auth is enabled by the `quarkus.http.auth.form.enabled=true` property.
// end::update_11_1[]

Then you need to add `elytron-security-properties-file` or `elytron-security-jdbc`.

== Security with Properties File

// tag::update_10_2[]
You can also protect endpoints and store identities (user, roles) in the file system.

[source, bash]
----
mvn quarkus:add-extension 
    -Dextensions="elytron-security-properties-file"
----

You need to configure the extension with users and roles files:

And configuration in `src/main/resources/application.properties`:

[source, properties]
----
quarkus.security.users.file.enabled=true
quarkus.security.users.file.users=test-users.properties
quarkus.security.users.file.roles=test-roles.properties
quarkus.security.users.file.auth-mechanism=BASIC
quarkus.security.users.file.realm-name=MyRealm
quarkus.security.users.file.plain-text=true
----

Then `users.properties` and `roles.properties`:

[source, properties]
----
scott=jb0ss 
jdoe=p4ssw0rd
----

[source, properties]
----
scott=Admin,admin,Tester,user 
jdoe=NoRolesUser
----

*IMPORTANT:*  If `plain-text` is set to `false` (or omitted) then passwords must be stored in the form MD5 (`username`:`realm`:`password`).

Elytron File Properties configuration properties.
Prefix `quarkus.security.users` is skipped.

|===	
| Parameter | Default | Description

a|`file.enabled`
a|`false`
|The file realm is enabled

a|`file.auth-mechanism`
a|`BASIC`
|The authentication mechanism

a|`file.realm-name`
a|`Quarkus`
|The authentication realm name

a|`file.plain-text`
a|`false`
|If passwords are in plain or in MD5

a|`file.users`
a|`users.properties`
|Classpath resource of user/password

a|`file.roles`
a|`roles.properties`
|Classpath resource of user/role
|===

*Embedded Realm*

You can embed user/password/role in the same `application.properties`:

[source, properties]
----
quarkus.security.users.embedded.enabled=true
quarkus.security.users.embedded.plain-text=true
quarkus.security.users.embedded.users.scott=jb0ss
quarkus.security.users.embedded.roles.scott=admin,tester,user
quarkus.security.users.embedded.auth-mechanism=BASIC
----

*IMPORTANT:*  If plain-text is set to `false` (or omitted) then passwords must be stored in the form MD5 (`username`:`realm`:`password`).

Prefix `quarkus.security.users.embedded` is skipped.

|===	
| Parameter | Default | Description

a|`file.enabled`
a|`false`
|The file realm is enabled

a|`file.auth-mechanism`
a|`BASIC`
|The authentication mechanism

a|`file.realm-name`
a|`Quarkus`
|The authentication realm name

a|`file.plain-text`
a|`false`
|If passwords are in plain or in MD5

a|`file.users.*`
a|
a|`*` is user and value is password

a|`file.roles.*`
a|
a|`*` is user and value is role
|===
// end::update_10_2[]

== Security with a JDBC Realm

// tag::update_9_7[]
You can also protect endpoints and store identities in a database.

[source, bash]
----
mvn quarkus:add-extension 
    -Dextensions="elytron-security-jdbc"
----

You still need to add the database driver (ie `jdbc-h2`).

You need to configure JDBC and Elytron JDBC Realm:

[source, properties]
----
quarkus.datasource.url=
quarkus.datasource.driver=org.h2.Driver
quarkus.datasource.username=sa
quarkus.datasource.password=sa

quarkus.security.jdbc.enabled=true
quarkus.security.jdbc.principal-query.sql=
    SELECT u.password, u.role FROM test_user u WHERE u.user=? 
quarkus.security.jdbc.principal-query
    .clear-password-mapper.enabled=true 
quarkus.security.jdbc.principal-query
    .clear-password-mapper.password-index=1
quarkus.security.jdbc.principal-query
    .attribute-mappings.0.index=2 
quarkus.security.jdbc.principal-query
    .attribute-mappings.0.to=groups
----

You need to set the index (1-based) of password and role.

Elytron JDBC Realm configuration properties.
Prefix `quarkus.security.jdbc` is skipped.

|===	
| Parameter | Default | Description

a|`auth-mechanism`
a|`BASIC`
|The authentication mechanism

a|`realm-name`
a|`Quarkus`
|The authentication realm name

a|`enabled`
a|`false`
|If the properties store is enabled

a|`principal-query.sql`
a|
|The sql query to find the password

a|`principal-query.datasource`
a|
|The data source to use

a|`principal-query.clear-password-mapper.enabled`
a|`false`
|If the clear-password-mapper is enabled

a|`principal-query.clear-password-mapper.password-index`
a|`1`
|The index of column containing clear password

a|`principal-query.bcrypt-password-mapper.enabled`
a|`false`
|If the bcrypt-password-mapper is enabled

a|`principal-query.bcrypt-password-mapper.password-index`
a|`0`
|The index of column containing password hash

a|`principal-query.bcrypt-password-mapper.hash-encoding`
a|`BASE64`
|A string referencing the password hash encoding (`BASE64` or `HEX`)

a|`principal-query.bcrypt-password-mapper.salt-index`
a|`0`
|The index column containing the Bcrypt salt

a|`principal-query.bcrypt-password-mapper.salt-encoding`
a|`BASE64`
|A string referencing the salt encoding (`BASE64` or `HEX`)

a|`principal-query.bcrypt-password-mapper.iteration-count-index`
a|`0`
|The index column containing the Bcrypt iteration count
|===

For multiple datasources you can use the datasource name in the properties:

[source, properties]
----
quarkus.datasource.url=
quarkus.security.jdbc.principal-query.sql=

quarkus.datasource.permissions.url=
quarkus.security.jdbc.principal-query.permissions.sql=
----
// end::update_9_7[]

== Vault

// tag::update_10_5[]
Quarkus integrates with https://www.vaultproject.io/[Vault] to manage secrets or protecting sensitive data. 

[source, bash]
----
mvn quarkus:add-extension 
    -Dextensions="vault"
----

And configuring Vault in `application.properties`:

[source, properties]
----
# vault url
quarkus.vault.url=http://localhost:8200

quarkus.vault.authentication.userpass.username=
    bob
quarkus.vault.authentication.userpass.password=
    sinclair

# path within the kv secret engine
quarkus.vault.secret-config-kv-path=
    myapps/vault-quickstart/config
quarkus.vault.secret-config-kv-path.singer=
    multi/singer
----

`vault kv put secret/myapps/vault-quickstart/config a-private-key=123456`

`vault kv put secret/multi/singer firstname=paul`

[source, java]
----
@ConfigProperty(name = "a-private-key")
String privateKey;

@ConfigProperty(name = "singer.firstname")
String firstName;
----

You can access the KV engine programmatically:

[source, java]
----
@Inject
VaultKVSecretEngine kvSecretEngine;

kvSecretEngine.readSecret("myapps/vault-quickstart/" + vaultPath).toString();
----

*Fetching credentials DB*

With the next _kv_ `vault kv put secret/myapps/vault-quickstart/db password=connor`

[source, properties]
----
quarkus.vault.credentials-provider.mydatabase.kv-path=
    myapps/vault-quickstart/db
quarkus.datasource.credentials-provider=
    mydatabase

quarkus.datasource.url= 
    jdbc:postgresql://localhost:5432/mydatabase
quarkus.datasource.driver= 
    org.postgresql.Driver
quarkus.datasource.username=
    sarah
----

No password is set as it is fetched from Vault.

INFO: https://www.vaultproject.io/docs/secrets/databases/index.html[dynamic database credentials] through the `database-credentials-role` property.

*Transit*

// tag::update_13_14[]
[source, java]
----
@Inject
VaultTransitSecretEngine transit;

transit.encrypt("my_encryption", text);
transit.decrypt("my_encryption", text).asString();
transit.sign("my-sign-key", text);
----
// end::update_13_14[]

Elytron JDBC Realm configuration properties.
Prefix `quarkus.vault` is skipped.

`url`::
Vault server URL

`authentication.client-token`::
Vault token to access

`authentication.app-role.role-id`::
Role Id for AppRole auth

`authentication.app-role.secret-id`::
Secret Id for AppRole auth

`authentication.userpass.username`::
Username for userpass auth

`authentication.userpass.password`::
Password for userpass auth

`authentication.kubernetes.role`::
Kubernetes authentication role

`authentication.kubernetes.jwt-token-path`::
Location of the file containing the Kubernetes JWT token

`renew-grace-period`::
Renew grace period duration (default: `1H`)

`secret-config-cache-period`::
Vault config source cache period (default: `10M`)

`secret-config-kv-path`::
Vault path in kv store. List of paths is supported in CSV

`log-confidentiality-level`::
Used to hide confidential infos. `low`, `medium`, `high` (default: `medium`)

`kv-secret-engine-version`::
Kv secret engine version (default: 1)

`kv-secret-engine-mount-path`
Kv secret engine path (default: `secret`)

`tls.skip-verify`::
Allows to bypass certificate validation on TLS communications (default: `false`)

`tls.ca-cert`::
Certificate bundle used to validate TLS communications

`tls.use-kubernetes-ca-cert`::
TLS will be active (default: `true`)

`connect-timeout`::
Tiemout to establish a connection (default: `5S`)

`read-timeout`::
Request timeout (default: `1S`)

`credentials-provider."credentials-provider".database-credentials-role`::
Database credentials role

`credentials-provider."credentials-provider".kv-path`::
A path in vault kv store, where we will find the kv-key

`credentials-provider."credentials-provider".kv-key`::
Key name to search in vault path kv-path (default: `password`)
// end::update_10_5[]
