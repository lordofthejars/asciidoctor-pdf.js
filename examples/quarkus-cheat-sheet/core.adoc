== Getting Started

Quarkus comes with a Maven archetype to scaffold a very simple starting project.

[source, bash, subs=attributes+]
----
mvn io.quarkus:quarkus-maven-plugin:{version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=getting-started \
    -DclassName="org.acme.quickstart.GreetingResource" \
    -Dpath="/hello"
----

This creates a simple JAX-RS resource called `GreetingResource`.

[source, java]
----
@Path("/hello")
public class GreetingResource {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "hello";
    }
}
----

== Gradle

// tag::update_10_8[]
There is no way to scaffold a project in Gradle but you only need to do:

[source, groovy]
----
plugins {
    id 'java'
    id 'io.quarkus' version '0.26.1' 
}

repositories {
    mavenCentral()
}

dependencies { 
    implementation enforcedPlatform('io.quarkus:quarkus-bom:0.26.1')
    implementation 'io.quarkus:quarkus-resteasy'
}
----

Or in Kotlin:

[source, kotlin]
----
plugins {
    java
}
apply(plugin = "io.quarkus")

repositories {
    mavenCentral()
}

dependencies {
    implementation(enforcedPlatform("io.quarkus:quarkus-bom:0.26.1"))
    implementation("io.quarkus:quarkus-resteasy")
}
----
// end::update_10_8[]

== Extensions

Quarkus comes with extensions to integrate with some libraries such as JSON-B, Camel or MicroProfile spec.
To list all available extensions just run:

[source, bash]
----
./mvnw quarkus:list-extensions
----

// tag::update_2_4[]
TIP: You can use `-DsearchPattern=panache` to filter out all extensions except the ones matching the expression.
// end::update_2_4[]

And to register the extensions into build tool:

[source, bash]
----
./mvnw quarkus:add-extension -Dextensions=""
----

TIP: `extensions` property supports CSV format to register more than one extension at once.

== Application Lifecycle
// tag::update_1_3[]
You can be notified when the application starts/stops by observing `StartupEvent` and `ShutdownEvent` events.

[source, java]
----
@ApplicationScoped
public class ApplicationLifecycle {
    void onStart(@Observes StartupEvent event) {}
    void onStop(@Observes ShutdownEvent event) {}
}
----
// end::update_1_3[]

== Adding Configuration Parameters

To add configuration to your application, Quarkus relies on https://github.com/eclipse/microprofile-config[MicroProfile Config, window="_blank"] spec.

[source, java]
----
@ConfigProperty(name = "greetings.message")
String message;

@ConfigProperty(name = "greetings.message",
                defaultValue = "Hello")
String messageWithDefault;

@ConfigProperty(name = "greetings.message")
Optional<String> optionalMessage;
----

Properties can be set as:

* Environment variables (`GREETINGS_MESSAGE`).
* System properties (`-Dgreetings.message`).
* Resources `src/main/resources/application.properties`.
* External config directory under the current working directory: `config/application.properties`.

[source, properties]
----
greetings.message = Hello World
----

// tag::update_2_7[]
TIP: `Array`, `List` and `Set` are supported. The delimiter is comma (`,`) char and `\` is the escape char.
// end::update_2_7[]

// tag::update_2_9[]
*Configuration Profiles*

Quarkus allow you to have multiple configuration in the same file (`application.properties`).

The syntax for this is `%{profile}.config.key=value`.

[source, properties]
----
quarkus.http.port=9090
%dev.quarkus.http.port=8181
----

HTTP port will be 9090, unless the 'dev' profile is active.

Default profiles are:

* `dev`: Activated when in development mode (`quarkus:dev`).
* `test`: Activated when running tests.
* `prod`: The default profile when not running in development or test mode

You can create custom profile names by enabling the profile either setting `quarkus.profile` system property or `QUARKUS_PROFILE` environment variable.

[source, properties]
----
quarkus.http.port=9090
%staging.quarkus.http.port=9999
----

And enable it `quarkus.profile=staging`.
// end::update_2_9[]

// tag::update_13_5[]
NOTE: To get the active profile programmatically use `io.quarkus.runtime.configuration.ProfileManager.getActiveProfile()`.
// end::update_13_5[]

// tag::update_6_7[]
You can also set it in the build tool:

[source, xml]
----
<groupId>org.apache.maven.plugins</groupId>
<artifactId>maven-surefire-plugin</artifactId>
<version>${surefire-plugin.version}</version>
<configuration>
    <systemPropertyVariables>
        <quarkus.test.profile>foo</quarkus.test.profile>
        <buildDirectory>${project.build.directory}
        </buildDirectory>
    </systemPropertyVariables>
</configuration>
----

TIP: Same for `maven-failsafe-plugin`.

[source, groovy]
----
test {
    useJUnitPlatform()
    systemProperty "quarkus.test.profile", "foo"
}
----
// end::update_6_7[]

// tag::update_13_7[]
Special properties are set in *prod* mode: `quarkus.application.version` and `quarkus.application.name` to get them available at runtime.

[source, java]
----
@ConfigProperty(name = "quarkus.application.name")
String applicationName;
----
// end::update_13_7[]

// tag::update_9_1[]
*@ConfigProperties*

As an alternative to injecting multiple related configuration values, you can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group properties.

[source, java]
----
@ConfigProperties(prefix = "greeting", namingStrategy=NamingStrategy.KEBAB_CASE)
public class GreetingConfiguration {
    private String message;
    // getter/setter
}
----

This class maps `greeting.message` property defined in `application.properties`.

You can inject this class by using CDI `@Inject GreetingConfiguration greeting;`.

Also you can use an interface approach:

[source, java]
----
@ConfigProperties(prefix = "greeting", namingStrategy=NamingStrategy.KEBAB_CASE)
public interface GreetingConfiguration {

    @ConfigProperty(name = "message")
    String message();
    String getSuffix();
----

If property does not follow getter/setter naming convention you need to use `org.eclipse.microprofile.config.inject.ConfigProperty` to set it.

Nested objects are also supporte:

[source, java]
----
@ConfigProperties(prefix = "greeting", namingStrategy=NamingStrategy.KEBAB_CASE)
public class GreetingConfiguration {
    public String message;
    public HiddenConfig hidden;

    public static class HiddenConfig {
        public List<String> recipients;
    }
}
----

And an `application.properties` mapping previous class:

[source, properties]
----
greeting.message = hello
greeting.hidden.recipients=Jane,John
----

Bean Validation is also supported so properties are validated at startup time, for example `@Size(min = 20) public String message;`.

TIP: `prefix` attribute is not mandatory. If not provided, attribute is determined by class name (ie `GreeetingConfiguration` is translated to `greeting` or `GreetingExtraConfiguration` to `greeting-extra`). The suffix of the class is always removed.
// end::update_9_1[]

// tag::update_13_11[]
Naming strategy can be changed with property `namingStrategy`. `KEBAB_CASE` (whatever.foo-bar) or `VERBATIM` (whatever.fooBar).
// end::update_13_11[]

*YAML Config*
// tag::update_12_12[]

YAML configuration is also supported.
The configuration file is called `application.yaml` and you need to register a dependency to enable its support:

[source, xml]
.pom.xml
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-config-yaml</artifactId>
</dependency>
----

[source, yaml]
----
quarkus:
  datasource:
    url: jdbc:postgresql://localhost:5432/some-database
    driver: org.postgresql.Driver
----

Or with profiles:

[source, yaml]
----
"%dev":
  quarkus:
    datasource:
      url: jdbc:postgresql://localhost:5432/some-database
      driver: org.postgresql.Driver
----

In case of subkeys `~` is used to refer to the unprefixed part.

[source, yaml]
----
quarkus:
  http:
    cors:
      ~: true
      methods: GET,PUT,POST
----

Is equivalent to:

[source, properties]
----
quarkus.http.cors=true
quarkus.http.cors.methods=GET,PUT,POST
----
// end::update_12_12[]

// tag::update_2_6[]

*Custom Loader*

You can implement your own `ConfigSource` to load configuration from different places than the default ones provided by Quarkus.
For example, database, custom XML, REST Endpoints, ...

You need to create a new class and implement `ConfigSource` interface:

[source, java]
----
package com.acme.config;
public class InMemoryConfig implements ConfigSource {

    private Map<String, String> prop = new HashMap<>();

    public InMemoryConfig() {
        // Init properties
    }

    @Override
    public int getOrdinal() {
        // The highest ordinal takes precedence
        return 900;
    }

    @Override
    public Map<String, String> getProperties() {
        return prop;
    }

    @Override
    public String getValue(String propertyName) {
        return prop.get(propertyName);
    }

    @Override
    public String getName() {
        return "MemoryConfigSource";
    }
}
----

Then you need to register the `ConfigSource` as Java service.
Create a file with the following content:

./META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource
[source]
----
com.acme.config.InMemoryConfig
----
// end::update_2_6[]

// tag::update_2_8[]
*Custom Converters*

You can implement your own conversion types from String.
Implement `org.eclipse.microprofile.config.spi.Converter` interface:

[source, java]
----
@Priority(DEFAULT_QUARKUS_CONVERTER_PRIORITY + 100)
public class CustomInstantConverter
    implements Converter<Instant> {

    @Override
    public Instant convert(String value) {
        if ("now".equals(value.trim())) {
            return Instant.now();
        }
        return Instant.parse(value);
    }
}
----

`@Priority` annotation is used to override the default `InstantConverter`.

Then you need to register the `Converter` as Java service.
Create a file with the following content:

./META-INF/services/org.eclipse.microprofile.config.spi.Converter
[source]
----
com.acme.config.CustomInstantConverter
----
// end::update_2_8[]

== Custom Context Path
// tag::update_6_2[]
By default Undertow will serve content from under the root context.
If you want to change this you can use the `quarkus.servlet.context-path` config key to set the context path.
// end::update_6_2[]

== Injection

Quarkus is based on CDI 2.0 to implement injection of code.
It is not fully supported and only a subset of the https://quarkus.io/guides/cdi-reference[specification is implemented, window="_blank"].

[source, java]
----
@ApplicationScoped
public class GreetingService {

    public String message(String message) {
        return message.toUpperCase();
    }
}
----

Scope annotation is mandatory to make the bean discoverable.

[source, java]
----
@Inject
GreetingService greetingService;
----

IMPORTANT: Quarkus is designed with Substrate VM in mind. For this reason, we encourage you to use _package-private_ scope instead of _private_.

*Produces*

// tag::update_5_4[]
You can also create a factory of an object by using `@javax.enterprise.inject.Produces` annotation.

[source, java]
----
@Produces
@ApplicationScoped
Message message() {
    Message m = new Message();
    m.setMsn("Hello");
    return m;
}

@Inject
Message msg;
----

*Qualifiers*

You can use qualifiers to return different implementations of the same interface or to customize the configuration of the bean.

[source, java]
----
@Qualifier
@Retention(RUNTIME)
@Target({TYPE, METHOD, FIELD, PARAMETER})
public @interface Quote {
    @Nonbinding String value();
}

@Produces
@Quote("")
Message message(InjectionPoint msg) {
    Message m = new Message();
    m.setMsn(
        msg.getAnnotated()
        .getAnnotation(Quote.class)
        .value()
    );

    return m;
}

@Inject
@Quote("Aloha Beach")
Message message;
----
// end::update_5_4[]

// tag::update_7_1[]
TIP: Quarkus breaks the CDI spec by allowing you to inject qualified beans without using `@Inject` annotation.

[source, java]
----
@Quote("Aloha Beach")
Message message;
----
// end::update_7_1[]

== JSON Marshalling/Unmarshalling

To work with `JSON-B` you need to add a dependency:

[source, bash]
----
./mvnw quarkus:add-extension
  -Dextensions="io.quarkus:quarkus-resteasy-jsonb"
----

Any POJO is marshaled/unmarshalled automatically.

[source, java]
----
public class Sauce {
    private String name;
    private long scovilleHeatUnits;

    // getter/setters
}
----

JSON equivalent:

[source, json]
----
{
	"name":"Blair's Ultra Death",
	"scovilleHeatUnits": 1100000
}
----

In a `POST` endpoint example:

[source, java]
----
@POST
@Consumes(MediaType.APPLICATION_JSON)
public Response create(Sauce sauce) {
    // Create Sauce
    return Response.created(URI.create(sauce.getId()))
            .build();
}
----

// tag::update_6_1[]
To work with `Jackson` you need to add:

[source, bash]
----
./mvnw quarkus:add-extension
  -Dextensions="quarkus-resteasy-jackson"
----

If you don't want to use the default `ObjectMapper` you can customize it by:

[source, java]
----
@ApplicationScoped
public class CustomObjectMapperConfig {
    @Singleton
    @Produces
    public ObjectMapper objectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();
        // perform configuration
        return objectMapper;
    }
}
----
// end::update_6_1[]

== XML Marshalling/Unmarshalling

// tag::update_9_8[]
To work with `JAX-B` you need to add a dependency:

[source, bash]
----
./mvnw quarkus:add-extension
  -Dextensions="quarkus-resteasy-jaxb"
----

Then annotated POJOs are converted to XML.

[source, java]
----
@XmlRootElement
public class Message {
}

 @GET
@Produces(MediaType.APPLICATION_XML)
public Message hello() {
    return message;
}
----
// end::update_9_8[]

== Validator

Quarkus uses https://hibernate.org/validator/[Hibernate Validator, window="_blank"] to validate input/output of REST services and business services using Bean validation spec.

[source, bash]
----
./mvnw quarkus:add-extension
  -Dextensions="io.quarkus:quarkus-hibernate-validator"
----

Annotate POJO objects with validator annotations such as: `@NotNull`, `@Digits`, `@NotBlank`, `@Min`, `@Max`, ...

[source, java]
----
public class Sauce {

    @NotBlank(message = "Name may not be blank")
    private String name;
    @Min(0)
    private long scovilleHeatUnits;

    // getter/setters
}
----

To validate an object use `@Valid` annotation:

[source, java]
----
public Response create(@Valid Sauce sauce) {}
----

TIP: If a validation error is triggered, a violation report is generated and serialized as JSON. If you want to manipulate the output, you need to catch in the code the `ConstraintViolationException` exception.

*Create Your Custom Constraints*

First you need to create the custom annotation:

[source, java]
----
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR,
            PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { NotExpiredValidator.class})
public @interface NotExpired {

    String message() default "Sauce must not be expired";
    Class<?>[] groups() default { };
    Class<? extends Payload>[] payload() default { };

}
----

You need to implement the validator logic in a class that implements `ConstraintValidator`.

[source, java]
----
public class NotExpiredValidator
    implements ConstraintValidator<NotExpired, LocalDate>
    {

    @Override
    public boolean isValid(LocalDate value,
                        ConstraintValidatorContext ctx) {
        if ( value == null ) return true;
        LocalDate today = LocalDate.now();
        return ChronoUnit.YEARS.between(today, value) > 0;
    }
}
----

And use it normally:

[source, java]
----
@NotExpired
@JsonbDateFormat(value = "yyyy-MM-dd")
private LocalDate expired;
----

*Manual Validation*

You can call the validation process manually instead of relaying to `@Valid` by injecting `Validator` class.

[source, java]
----
@Inject
Validator validator;
----

And use it:

[source, java]
----
Set<ConstraintViolation<Sauce>> violations =
            validator.validate(sauce);
----

*Localization*

// tag::update_13_13[]
You can configure the based on locale.

[source, properties]
----
quarkus.default-locale=ca-ES
# Supported locales resolved by Accept-Language
quarkus.locales=en-US,es-ES,fr-FR, ca_ES
----

[source, properties]
.ValidationMessages_ca_ES.properties
----
pattern.message=No conforme al patro
----

[source, java]
----
@Pattern(regexp = "A.*", message = "{pattern.message}")
private String name;
----
// end::update_13_13[]

== Logging

You can configure how Quarkus logs:

[source, properties]
----
quarkus.log.console.enable=true
quarkus.log.console.level=DEBUG
quarkus.log.console.color=false
quarkus.log.category."com.lordofthejars".level=DEBUG
----

Prefix is `quarkus.log`.

`category."<category-name>".level`::
Minimum level category (default: `INFO`)

`level`::
Default minimum level (default: `INFO`)

`console.enabled`::
Console logging enabled (default: `true`)

`console.format`::
Format pattern to use for logging. Default value: +
`%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c{3.}] (%t) %s%e%n`

`console.level`::
Minimum log level (default: `INFO`)

`console.color`::
Allow color rendering (default: `true`)

`file.enable`::
File logging enabled (default: `false`)

`file.format`::
Format pattern to use for logging. Default value: +
`%d{yyyy-MM-dd HH:mm:ss,SSS} %h %N[%i] %-5p [%c{3.}] (%t) %s%e%n`

`file.level`::
Minimum log level (default: `ALL`)

`file.path`::
The path to log file (default: `quarkus.log`)

`file.rotation.max-file-size`::
The maximum file size of the log file

`file.rotation.max-backup-index`::
The maximum number of backups to keep (default: `1`)

`file.rotation.file-suffix`::
Rotating log file suffix.

`file.rotation.rotate-on-boot`::
Indicates rotate logs at bootup (default: `true`)

`file.async`::
Log asynchronously (default: `false`)

`file.async.queue-length`::
The queue length to use before flushing writing (default: `512`)

`file.async.overflow`::
Action when queue is full (default: `BLOCK`)

`syslog.enable`::
syslog logging is enabled (default: `false`)

`syslog.format`::
The format pattern to use for logging to syslog. Default value: +
`%d{yyyy-MM-dd HH:mm:ss,SSS} %h %N[%i] %-5p [%c{3.}] (%t) %s%e%n`

`syslog.level`::
The minimum log level to write to syslog (default: `ALL`)

`syslog.endpoint`::
The IP address and port of the syslog server (default: `localhost:514`)

`syslog.app-name`::
The app name used when formatting the message in RFC5424 format (default: current process name)

`syslog.hostname`::
The name of the host the messages are being sent from (default: current hostname)

`syslog.facility`::
Priority of the message as defined by RFC-5424 and RFC-3164 (default: `USER_LEVEL`)

`syslog.syslog-type`::
The syslog type of format message (default: `RFC5424`)

`syslog.protocol`::
Protocol used (default: `TCP`)

`syslog.use-counting-framing`::
Message prefixed with the size of the message (default `false`)

`syslog.truncate`::
Message should be truncated (default: `true`)

`syslog.block-on-reconnect`::
Block when attempting to reconnect (default: `true`)

`syslog.async`::
Log asynchronously (default: `false`)

`syslog.async.queue-length`::
The queue length to use before flushing writing (default: `512`)

`syslog.async.overflow`::
Action when queue is full (default: `BLOCK`)

*Gelf ouput*
// tag::update_13_4[]

You can configure the output to be in _GELF_ format instead of plain text.

[source, shell-session]
----
./mvnw quarkus:add-extension
  -Dextensions="quarkus-logging-gelf"
----

`handler.gelf.enabled`::
Enable GELF logging handler (default: `false`)

`handler.gelf.host`::
Hostname/IP of Logstash/Graylof. Prepend `tcp:` for using TCP protocol. (default: `udp:localhost`)

`handler.gelf.port`::
The port. (default: `12201`)

`handler.gelf.version`::
GELF version. (default: `1.1`)

`handler.gelf.extract-stack-trace`::
Post Stack-Trace to StackTrace field. (default: `true`)

`handler.gelf.stack-trace-throwable-reference`::
Gets the cause level to stack trace. `0` is fulls tack trace. (default: `0`)

`handler.gelf.filter-stack-trace`::
Stack-Trace filtering. (default: `false`)

`handler.gelf.timestamp-pattern`::
Java Date pattern. (default: `yyyy-MM-dd HH:mm:ss,SSS`)

`handler.gelf.level`::
Log level `java.util.logging.Level`. (default: `ALL`)

`handler.gelf.facility`::
Name of the facility. (default: `jboss-logmanage`)

`handler.gelf.additional-field.<field>.<subfield>`::
Post additional fields. `quarkus.log.handler.gelf.additional-field.field1.type=String`
// end::update_13_4[]

*JSON output*
// tag::update_12_9[]

You can configure the output to be in _JSON_ format instead of plain text.

[source, shell-session]
----
./mvnw quarkus:add-extension
  -Dextensions="quarkus-logging-json"
----

And the configuration values are prefix with `quarkus.log`:

`json`::
JSON logging is enabled (default: true).

`json.pretty-print`::
JSON output is "pretty-printed" (default: false)

`json.date-format`::
Specify the date format to use (default: the default format)

`json.record-delimiter`::
Record delimiter to add (default: no delimiter)

`json.zone-id`::
The time zone ID

`json.exception-output-type`::
The exception output type: `detailed`, `formatted`, `detailed-and-formatted` (default: `detailed`)

`json.print-details`::
Detailed caller information should be logged (default: false)
// end::update_12_9[]

== Rest Client

Quarkus implements https://github.com/eclipse/microprofile-rest-client[MicroProfile Rest Client, window="_blank"] spec:

[source, bash]
----
./mvnw quarkus:add-extension
  -Dextensions="quarkus-rest-client"
----

To get content from http://worldclockapi.com/api/json/cet/now you need to create a service interface:

[source, java]
----
@Path("/api")
@RegisterRestClient
public interface WorldClockService {

    @GET @Path("/json/cet/now")
    @Produces(MediaType.APPLICATION_JSON)
    WorldClock getNow();

    @GET
    @Path("/json/{where}/now")
    @Produces(MediaType.APPLICATION_JSON)
    WorldClock getSauce(@BeanParam
                    WorldClockOptions worldClockOptions);

}
----

[source, java]
----
public class WorldClockOptions {
    @HeaderParam("Authorization")
    String auth;

    @PathParam("where")
    String where;
}
----

And configure the hostname at `application.properties`:

[source, properties]
----
org.acme.quickstart.WorldClockService/mp-rest/url=
        http://worldclockapi.com
----

Injecting the client:

[source, java]
----
@RestClient
WorldClockService worldClockService;
----

// tag::update_1_1[]
If invokation happens within JAX-RS, you can propagate headers from incoming to outgoing by using next property.

[source, properties]
----
org.eclipse.microprofile.rest.client.propagateHeaders=
            Authorization,MyCustomHeader
----
// end::update_1_1[]

TIP: You can still use the JAX-RS client without any problem `ClientBuilder.newClient().target(...)`

*Adding headers*

You can customize the headers passed by implementing MicroProfile `ClientHeadersFactory` annotation:

[source, java]
----
@RegisterForReflection
public class BaggageHeadersFactory
                implements ClientHeadersFactory {
    @Override
    public MultivaluedMap<String, String> update(
        MultivaluedMap<String, String> incomingHeaders,
        MultivaluedMap<String, String> outgoingHeaders) {}
}
----

And registering it in the client using `RegisterClientHeaders` annotation.

[source, java]
----
@RegisterClientHeaders(BaggageHeadersFactory.class)
@RegisterRestClient
public interface WorldClockService {}
----

Or statically set:

[source, java]
----
@GET
@ClientHeaderParam(name="X-Log-Level", value="ERROR")
Response getNow();
----

*Asynchronous*

A method on client interface can return a `CompletionStage` class to be executed asynchronously.

[source, java]
----
@GET @Path("/json/cet/now")
@Produces(MediaType.APPLICATION_JSON)
CompletionStage<WorldClock> getNow();
----

*Multipart*

// tag::update_10_10[]
It is really easy to send multipart form-data with Rest Client.

[source, xml]
----
<dependency>
    <groupId>org.jboss.resteasy</groupId>
    <artifactId>resteasy-multipart-provider</artifactId>
</dependency>
----

The model object:

[source, java]
----
import java.io.InputStream;

import javax.ws.rs.FormParam;
import javax.ws.rs.core.MediaType;

import 
    org.jboss.resteasy.annotations.providers.multipart.PartType;

public class MultipartBody {

    @FormParam("file")
    @PartType(MediaType.APPLICATION_OCTET_STREAM)
    private InputStream file;

    @FormParam("fileName")
    @PartType(MediaType.TEXT_PLAIN)
    private String name;

    // getter/setters
}
----

And the Rest client interface:

[source, java]
----
import 
    org.jboss.resteasy.annotations.providers.multipart.MultipartForm;

@Path("/echo")
@RegisterRestClient
public interface MultipartService {

    @POST
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    @Produces(MediaType.TEXT_PLAIN)
    String sendMultipartData(@MultipartForm 
                        MultipartBody data);

}
----
// end::update_10_10[]

// tag::update_11_4[]
*SSL*

You can configure Rest Client key stores.

[source, properties]
----
org.acme.quickstart.WorldClockService/mp-rest/trustStore=
    classpath:/store.jks
org.acme.quickstart.WorldClockService/mp-rest/trustStorePassword=
    supersecret
----

Possible configuration properties:

`%s/mp-rest/trustStore`::
Trust store location defined with `classpath:` or `file:` prefix.

`%s/mp-rest/trustStorePassword`::
Trust store password.

`%s/mp-rest/trustStoreType`::
Trust store type (default: `JKS`)

`%s/mp-rest/hostnameVerifier`::
Custom hostname verifier class name.

`%s/mp-rest/keyStore`::
Key store location defined with `classpath:` or `file:` prefix.

`%s/mp-rest/keyStorePassword`::
Key store password.

`%s/mp-rest/keyStoreType`::
Key store type (default: `JKS`)
// end::update_11_4[]

// tag::update_11_5[]
*Timeout* 

You can define the timeout of the Rest Client:

[source, properties]
----
org.acme.quickstart.WorldClockService/mp-rest/connectTimeout=
    1000
org.acme.quickstart.WorldClockService/mp-rest/readTimeout=
    2000
----
// end::update_11_5[]

== Testing

Quarkus archetype adds test dependencies with JUnit 5 and Rest-Assured library to test REST endpoints.

[source, java]
----
@QuarkusTest
public class GreetingResourceTest {

    @Test
    public void testHelloEndpoint() {
        given()
          .when().get("/hello")
          .then()
             .statusCode(200)
             .body(is("hello"));
    }
}
----

Test port can be set in `quarkus.http.test-port` property.

You can also inject the URL where Quarkus is started:

[source, java]
----
@TestHTTPResource("index.html")
URL url;
----

*Quarkus Test Resource*

// tag::update_4_2[]
You can execute some logic before the first test run (`start`) and execute some logic at the end of the test suite (`stop`).

You need to create a class implementing `QuarkusTestResourceLifecycleManager` interface and register it in the test via `@QuarkusTestResource` annotation.

[source, java]
----
public class MyCustomTestResource
    implements QuarkusTestResourceLifecycleManager {

    @Override
    public Map<String, String> start() {
        // return system properties that
        // should be set for the running test
        return Collections.emptyMap();
    }

    @Override
    public void stop() {
    }

    // optional
    @Override
    public void inject(Object testInstance) {
    }

    // optional
    @Override
    public int order() {
        return 0;
    }
}
----

IMPORTANT: Returning new system properties implies running parallel tests in different JVMs.

And the usage:

[source, java]
----
@QuarkusTestResource(MyCustomTestResource.class)
public class MyTest {
}
----

// end::update_4_2[]
*Mocking*

If you need to provide an alternative implementation of a service (for testing purposes) you can do it by using CDI `@Alternative` annotation using it in the test service placed at `src/test/java`:

[source, java]
----
@Alternative
@Priority(1)
@ApplicationScoped
public class MockExternalService extends ExternalService {}
----

IMPORTANT: This does not work when using native image testing.

// tag::update_3_6[]
A stereotype annotation `io.quarkus.test.Mock` is provided declaring `@Alternative`, `@Priority(1)` and `@Dependent`.
// end::update_3_6[]

*Interceptors*
// tag::update_5_5[]

Tests are actually full CDI beans, so you can apply CDI interceptors:

[source, java]
----
@QuarkusTest
@Stereotype
@Transactional
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface TransactionalQuarkusTest {
}

@TransactionalQuarkusTest
public class TestStereotypeTestCase {}
----
// end::update_5_5[]

*Test Coverage*
// tag::update_6_3[]
Due the nature of Quarkus to calculate correctly the coverage information with JaCoCo, you might need offline instrumentation.
I recommend reading https://quarkus.io/guides/tests-with-coverage-guide[this document, window="_blank"] to understand how JaCoCo and Quarkus works and how you can configure JaCoCo to get correct data.
// end::update_6_3[]

*Native Testing*

To test native executables annotate the test with `@NativeImageTest`.
