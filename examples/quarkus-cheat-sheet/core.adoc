== Getting Started

Quarkus comes with a Maven archetype to scaffold a very simple starting project.

[source, bash, subs=attributes+]
----
mvn io.quarkus:quarkus-maven-plugin:{version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=getting-started \
    -DclassName="org.acme.quickstart.GreetingResource" \
    -Dpath="/hello"
----

This creates a simple JAX-RS resource called `GreetingResource`.

[source, java]
----
@Path("/hello")
public class GreetingResource {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "hello";
    }
}
----

== Gradle

// tag::update_10_8[]
There is no way to scaffold a project in Gradle but you only need to do:

[source, groovy]
----
plugins {
    id 'java'
    id 'io.quarkus' version '0.26.1' 
}

repositories {
    mavenCentral()
}

dependencies { 
    implementation enforcedPlatform('io.quarkus:quarkus-bom:0.26.1')
    implementation 'io.quarkus:quarkus-resteasy'
}
----

Or in Kotlin:

[source, kotlin]
----
plugins {
    java
}
apply(plugin = "io.quarkus")

repositories {
    mavenCentral()
}

dependencies {
    implementation(enforcedPlatform("io.quarkus:quarkus-bom:0.26.1"))
    implementation("io.quarkus:quarkus-resteasy")
}
----
// end::update_10_8[]

== Packaging

// tag::update_16_26[]
[source, bash-shell]
----
mvn clean package
----

You need to distribute the `-runner.jar` file together with `lib` directory.

If `quarkus.package.uber-jar` property is set to true, then a uber-jar is created with all dependencies bundled inside the JAR.

If `quarkus.package.type` property is set to `fast-jar` then Quarkus brings a JAR with faster startup times.

[source, properties]
.application.properties
----
quarkus.package.uber-jar=true
quarkus.package.type=fast-jar
----

To compile to native, you need to set `GRAALVM_HOME` environment variable and run the `native` profile.

[source, bash-shell]
----
mvn clean package -Pnative

./gradlew build -Dquarkus.package.type=native
----
// end::update_16_26[]

// tag::update_17_5[]
Possible `quarkus.package.type` are: `jar`, `fast-jar`, `uber-jar` and `native`.
// end::update_17_5[]

*AppCDS*

// tag::update_17_11[]
Automatically generate AppCDS as part of the build process set the next property: `quarkus.package.create-appcds=true`.

To make use of it, just run `java -jar -XX:SharedArchiveFile=app-cds.jsa myapp.jar`.
// end::update_17_11[]

== Command mode

// tag::update_15_16[]
You can define the `main` CLI method to start Quarkus.
There are two ways, implementing `io.quarkus.runtime.QuarkusApplication` interface or use the Java main method to launch Quarkus.

[source, java]
----
@io.quarkus.runtime.annotations.QuarkusMain
public class HelloWorldMain implements QuarkusApplication {
  @Override
  public int run(String... args) throws Exception {
    System.out.println("Hello World");
    return 10;
 }
}
----

`run` method called when Quarkus starts, and stops when it finishes.

As Java `main`:

[source, java]
----
@QuarkusMain
public class JavaMain {
    public static void main(String... args) {
        Quarkus.run(HelloWorldMain.class, args);
    }
}
----

IMPORTANT: Use `@QuarkusMain` in only one place.

Use `Quarkus.waitForExit()` from the main thread if you want to run some logic on startup, and then run like a normal application (i.e. not exit).

You can inject command line arguments by using `@CommandLineArguments` annotation:

[source, java]
----
@CommandLineArguments
String[] args;
----
// end::update_15_16[]

// tag::update_16_15[]
*Picocli*

You can use Picocli to implement CLI applications:

[source, bash]
----
./mvnw quarkus:add-extension 
  -Dextensions="picocli"
----

[source, java]
----
@CommandLine.Command
public class HelloCommand implements Runnable {
    
    @CommandLine.Option(names = {"-n", "--name"}, description = "Who will we greet?", defaultValue = "World")
    String name;
    
    private final GreetingService greetingService;
    
    public HelloCommand(GreetingService greetingService) {
        this.greetingService = greetingService;
    }
    
    @Override
    public void run() {
        greetingService.sayHello(name);
    }
}
----

All classes annotated with `picocli.CommandLine.Command` are registered as CDI beans.

If only one class annotated with `picocli.CommandLine.Command` it will be used as entry point. 
If you want to provide your own `@QuarkusMain`:

[source, java]
----
@QuarkusMain
@CommandLine.Command(name = "demo", mixinStandardHelpOptions = true)
public class ExampleApp implements Runnable, QuarkusApplication {
    
    @Inject
    CommandLine.IFactory factory;
    
    @Override
    public void run() {
    }

    @Override
    public int run(String... args) throws Exception {
        return new CommandLine(this, factory).execute(args);
    }
}
----

Use `quarkus.picocli.native-image.processing.enable` to `false` to use the `picocli-codegen` annotation processor instead of build steps.
// end::update_16_15[]

// tag::update_17_1[]
You can also configure CDI beans with PicoCLI arguments:

[source, java]
----
@CommandLine.Command
public class EntryCommand implements Runnable {
    @CommandLine.Option(names = "-c", description = "JDBC connection string")
    String connectionString;
    
    @Inject
    DataSource dataSource;
}

@ApplicationScoped
class DatasourceConfiguration {
    
    @Produces
    @ApplicationScoped
    DataSource dataSource(CommandLine.ParseResult parseResult) {
        System.out.println(parseResult.matchedOption("c").getValue().toString());
    }
}
----
// end::update_17_1[]

== Extensions

Quarkus comes with extensions to integrate with some libraries such as JSON-B, Camel or MicroProfile spec.
To list all available extensions just run:

[source, bash]
----
./mvnw quarkus:list-extensions
----

// tag::update_2_4[]
TIP: You can use `-DsearchPattern=panache` to filter out all extensions except the ones matching the expression.
// end::update_2_4[]

And to register the extensions into build tool:

[source, bash]
----
./mvnw quarkus:add-extension -Dextensions=""

./mvnw quarkus:remove-extension -Dextensions=""
----

TIP: `extensions` property supports CSV format to register more than one extension at once.

== Application Lifecycle
// tag::update_1_3[]
You can be notified when the application starts/stops by observing `StartupEvent` and `ShutdownEvent` events.

[source, java]
----
@ApplicationScoped
public class ApplicationLifecycle {
    void onStart(@Observes StartupEvent event) {}
    void onStop(@Observes ShutdownEvent event) {}
}
----
// end::update_1_3[]

// tag::update_14_31[]
Quarkus supports graceful shutdown.
By default there is no timeout but can be set by using the `quarkus.shutdown.timeout` config property.
// end::update_14_31[]

== Dev Mode

// tag::update_17_14[]
[source, bash]
----
./mvnw compile quarkus:dev

./gradlew quarkusDev
----

Endpoints are registered automatically to provide some basic debug info in dev mode:

* `HTTP GET /quarkus/arc/beans`
** Query Parameters: `scope`, `beanClass`, `kind`.
* `HTTP GET /quarkus/arc/observers`
// end::update_17_14[]

== Adding Configuration Parameters

To add configuration to your application, Quarkus relies on https://github.com/eclipse/microprofile-config[MicroProfile Config, window="_blank"] spec.

[source, java]
----
@ConfigProperty(name = "greetings.message")
String message;

@ConfigProperty(name = "greetings.message",
                defaultValue = "Hello")
String messageWithDefault;

@ConfigProperty(name = "greetings.message")
Optional<String> optionalMessage;
----

// tag::update_14_6[]
Properties can be set (in decreasing priority) as:

* System properties (`-Dgreetings.message`).
* Environment variables (`GREETINGS_MESSAGE`).
* Environment file named `.env` placed in the current working directory (`GREETING_MESSAGE=`).
* External config directory under the current working directory: `config/application.properties`.
* Resources `src/main/resources/application.properties`.
// end::update_14_6[]

[source, properties]
----
greetings.message = Hello World
----

// tag::update_2_7[]
TIP: `Array`, `List` and `Set` are supported. The delimiter is comma (`,`) char and `\` is the escape char.
// end::update_2_7[]

// tag::update_2_9[]
*Configuration Profiles*

Quarkus allow you to have multiple configuration in the same file (`application.properties`).

The syntax for this is `%{profile}.config.key=value`.

[source, properties]
----
quarkus.http.port=9090
%dev.quarkus.http.port=8181
----

HTTP port will be 9090, unless the 'dev' profile is active.

Default profiles are:

* `dev`: Activated when in development mode (`quarkus:dev`).
* `test`: Activated when running tests.
* `prod`: The default profile when not running in development or test mode

You can create custom profile names by enabling the profile either setting `quarkus.profile` system property or `QUARKUS_PROFILE` environment variable.

[source, properties]
----
quarkus.http.port=9090
%staging.quarkus.http.port=9999
----

And enable it `quarkus.profile=staging`.
// end::update_2_9[]

// tag::update_13_5[]
NOTE: To get the active profile programmatically use `io.quarkus.runtime.configuration.ProfileManager.getActiveProfile()`.
// end::update_13_5[]

// tag::update_6_7[]
You can also set it in the build tool:

[source, xml]
----
<groupId>org.apache.maven.plugins</groupId>
<artifactId>maven-surefire-plugin</artifactId>
<version>${surefire-plugin.version}</version>
<configuration>
    <systemPropertyVariables>
        <quarkus.test.profile>foo</quarkus.test.profile>
        <buildDirectory>${project.build.directory}
        </buildDirectory>
    </systemPropertyVariables>
</configuration>
----

TIP: Same for `maven-failsafe-plugin`.

[source, groovy]
----
test {
    useJUnitPlatform()
    systemProperty "quarkus.test.profile", "foo"
}
----
// end::update_6_7[]

// tag::update_13_7[]
Special properties are set in *prod* mode: `quarkus.application.version` and `quarkus.application.name` to get them available at runtime.

[source, java]
----
@ConfigProperty(name = "quarkus.application.name")
String applicationName;
----
// end::update_13_7[]

// tag::update_9_1[]
*@ConfigProperties*

As an alternative to injecting multiple related configuration values, you can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group properties.

[source, java]
----
@ConfigProperties(prefix = "greeting", namingStrategy=NamingStrategy.KEBAB_CASE)
public class GreetingConfiguration {
    private String message;
    // getter/setter
}
----

This class maps `greeting.message` property defined in `application.properties`.

You can inject this class by using CDI `@Inject GreetingConfiguration greeting;`.

Also you can use an interface approach:

[source, java]
----
@ConfigProperties(prefix = "greeting", namingStrategy=NamingStrategy.KEBAB_CASE)
public interface GreetingConfiguration {

    @ConfigProperty(name = "message")
    String message();
    String getSuffix();
----

If property does not follow getter/setter naming convention you need to use `org.eclipse.microprofile.config.inject.ConfigProperty` to set it.

Nested objects are also supporte:

[source, java]
----
@ConfigProperties(prefix = "greeting", namingStrategy=NamingStrategy.KEBAB_CASE)
public class GreetingConfiguration {
    public String message;
    public HiddenConfig hidden;

    public static class HiddenConfig {
        public List<String> recipients;
    }
}
----

And an `application.properties` mapping previous class:

[source, properties]
----
greeting.message = hello
greeting.hidden.recipients=Jane,John
----

Bean Validation is also supported so properties are validated at startup time, for example `@Size(min = 20) public String message;`.

TIP: `prefix` attribute is not mandatory. If not provided, attribute is determined by class name (ie `GreeetingConfiguration` is translated to `greeting` or `GreetingExtraConfiguration` to `greeting-extra`). The suffix of the class is always removed.
// end::update_9_1[]

// tag::update_13_11[]
Naming strategy can be changed with property `namingStrategy`. `KEBAB_CASE` (whatever.foo-bar) or `VERBATIM` (whatever.fooBar).
// end::update_13_11[]

// tag::update_17_2[]
`@io.quarkus.arc.config.ConfigIgnore` annotation can be used to ignore the injection of configuration elements.

[source, java]
----
@ConfigIgnore
public Integer ignored;
----
// end::update_17_2[]

*YAML Config*
// tag::update_12_12[]

YAML configuration is also supported.
The configuration file is called `application.yaml` and you need to register a dependency to enable its support:

[source, xml]
.pom.xml
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-config-yaml</artifactId>
</dependency>
----

[source, yaml]
----
quarkus:
  datasource:
    url: jdbc:postgresql://localhost:5432/some-database
    driver: org.postgresql.Driver
----

Or with profiles:

[source, yaml]
----
"%dev":
  quarkus:
    datasource:
      url: jdbc:postgresql://localhost:5432/some-database
      driver: org.postgresql.Driver
----

In case of subkeys `~` is used to refer to the unprefixed part.

[source, yaml]
----
quarkus:
  http:
    cors:
      ~: true
      methods: GET,PUT,POST
----

Is equivalent to:

[source, properties]
----
quarkus.http.cors=true
quarkus.http.cors.methods=GET,PUT,POST
----
// end::update_12_12[]

// tag::update_2_6[]

*Custom Loader*

You can implement your own `ConfigSource` to load configuration from different places than the default ones provided by Quarkus.
For example, database, custom XML, REST Endpoints, ...

You need to create a new class and implement `ConfigSource` interface:

[source, java]
----
package com.acme.config;
public class InMemoryConfig implements ConfigSource {

    private Map<String, String> prop = new HashMap<>();

    public InMemoryConfig() {
        // Init properties
    }

    @Override
    public int getOrdinal() {
        // The highest ordinal takes precedence
        return 900;
    }

    @Override
    public Map<String, String> getProperties() {
        return prop;
    }

    @Override
    public String getValue(String propertyName) {
        return prop.get(propertyName);
    }

    @Override
    public String getName() {
        return "MemoryConfigSource";
    }
}
----

Then you need to register the `ConfigSource` as Java service.
Create a file with the following content:

./META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource
[source]
----
com.acme.config.InMemoryConfig
----
// end::update_2_6[]

// tag::update_2_8[]
*Custom Converters*

You can implement your own conversion types from String.
Implement `org.eclipse.microprofile.config.spi.Converter` interface:

[source, java]
----
@Priority(DEFAULT_QUARKUS_CONVERTER_PRIORITY + 100)
public class CustomInstantConverter
    implements Converter<Instant> {

    @Override
    public Instant convert(String value) {
        if ("now".equals(value.trim())) {
            return Instant.now();
        }
        return Instant.parse(value);
    }
}
----

`@Priority` annotation is used to override the default `InstantConverter`.

Then you need to register the `Converter` as Java service.
Create a file with the following content:

./META-INF/services/org.eclipse.microprofile.config.spi.Converter
[source]
----
com.acme.config.CustomInstantConverter
----
// end::update_2_8[]

== Undertow Properties

// tag::update_15_1[]
Possible parameters with prefix `quarkus.servlet`:

`context-path`::
The context path to serve all Servlet context from. (default: `/`)

`default-charset`::
The default charset to use for reading and writing requests. (default: `UTF-8`)
// end::update_15_1[]

== Injection

Quarkus is based on CDI 2.0 to implement injection of code.
It is not fully supported and only a subset of the https://quarkus.io/guides/cdi-reference[specification is implemented, window="_blank"].

[source, java]
----
@ApplicationScoped
public class GreetingService {

    public String message(String message) {
        return message.toUpperCase();
    }
}
----

Scope annotation is mandatory to make the bean discoverable.

[source, java]
----
@Inject
GreetingService greetingService;
----

IMPORTANT: Quarkus is designed with Substrate VM in mind. For this reason, we encourage you to use _package-private_ scope instead of _private_.

*Produces*

// tag::update_5_4[]
You can also create a factory of an object by using `@javax.enterprise.inject.Produces` annotation.

[source, java]
----
@Produces
@ApplicationScoped
Message message() {
    Message m = new Message();
    m.setMsn("Hello");
    return m;
}

@Inject
Message msg;
----

*Qualifiers*

You can use qualifiers to return different implementations of the same interface or to customize the configuration of the bean.

[source, java]
----
@Qualifier
@Retention(RUNTIME)
@Target({TYPE, METHOD, FIELD, PARAMETER})
public @interface Quote {
    @Nonbinding String value();
}

@Produces
@Quote("")
Message message(InjectionPoint msg) {
    Message m = new Message();
    m.setMsn(
        msg.getAnnotated()
        .getAnnotation(Quote.class)
        .value()
    );

    return m;
}

@Inject
@Quote("Aloha Beach")
Message message;
----
// end::update_5_4[]

// tag::update_7_1[]
TIP: Quarkus breaks the CDI spec by allowing you to inject qualified beans without using `@Inject` annotation.

[source, java]
----
@Quote("Aloha Beach")
Message message;
----
// end::update_7_1[]

// tag::update_15_10[]
TIP: Quarkus breaks the CDI spec by skipping the `@Produces` annotation completely if the producer method is annotated with a scope annotation, a stereotype or a qualifier. 

[source,java]
----
@Quote("")
Message message(InjectionPoint msg) {
}

@Quote("Aloha Beach")
Message message;
----
// end::update_15_10[]

*Alternatives*

// tag::update_15_11[]
It is also possible to select alternatives for an application using `application.properties`.

[source, properties]
----
quarkus.arc.selected-alternatives=org.acme.Foo,org.acme.*,Bar
----
// end::update_15_11[] 

*Beans by Quarkus Profile*

// tag::update_15_15[]
Using `@io.quarkus.arc.profile.IfBuildProfile` and `@io.quarkus.arc.profile.UnlessBuildProfile` annotations, you can conditionally enable a bean.

[source,java]
----
@Dependent
public class TracerConfiguration {
    @Produces
    @IfBuildProfile("prod")
    public Tracer realTracer(Reporter reporter, Configuration configuration) {
        return new RealTracer(reporter, configuration);
    }
    @Produces
    @DefaultBean
    public Tracer noopTracer() {
        return new NoopTracer();
    }
}
----
// end::update_15_15[]

// tag::update_16_1[]
Using `@io.quarkus.arc.profile.IfBuildProperty` annotation, you can conditionally enable a bean.
`@io.quarkus.arc.DefaultBean` sets the default bean.

[source, java]
----
@Dependent
public class TracerConfiguration {
    @Produces
    @IfBuildProperty(name = "some.tracer.enabled", stringValue = "true")
    public Tracer realTracer(Reporter reporter, Configuration configuration) {}
    
    @Produces
    @DefaultBean
    public Tracer noopTracer() {}
}
----

NOTE: Properties set at runtime have absolutely no effect on the bean resolution using `@IfBuildProperty`.

// end::update_16_1[]

// tag::update_18_8[]
*Container-managed Concurrency*

Quarkus provides `@io.quarkus.arc.Lock` and a built-in interceptor for concurrency control.

[source, java]
----
@Lock
@ApplicationScoped
class SharedService {
  
    void addAmount(BigDecimal amout) {
    }
  
    @Lock(value = Lock.Type.READ, time = 1, unit = TimeUnit.SECONDS)
    BigDecimal getAmount() {
    }
}
----

By default the class is in write mode (so no concurrent calls allowed) except when lock type is `READ` where the method can be called concurrently if no write operation in process.
// end::update_18_8[]

== JSON Marshalling/Unmarshalling

To work with `JSON-B` you need to add a dependency:

[source, bash]
----
./mvnw quarkus:add-extension
  -Dextensions="io.quarkus:quarkus-resteasy-jsonb"
----

Any POJO is marshaled/unmarshalled automatically.

[source, java]
----
public class Sauce {
    private String name;
    private long scovilleHeatUnits;

    // getter/setters
}
----

JSON equivalent:

[source, json]
----
{
	"name":"Blair's Ultra Death",
	"scovilleHeatUnits": 1100000
}
----

In a `POST` endpoint example:

[source, java]
----
@POST
@Consumes(MediaType.APPLICATION_JSON)
public Response create(Sauce sauce) {
    // Create Sauce
    return Response.created(URI.create(sauce.getId()))
            .build();
}
----

// tag::update_6_1[]
To work with `Jackson` you need to add:

[source, bash]
----
./mvnw quarkus:add-extension
  -Dextensions="quarkus-resteasy-jackson"
----

If you don't want to use the default `ObjectMapper` you can customize it by:

[source, java]
----
@ApplicationScoped
public class CustomObjectMapperConfig {
    @Singleton
    @Produces
    public ObjectMapper objectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();
        // perform configuration
        return objectMapper;
    }
}
----
// end::update_6_1[]

// tag::update_21_8[]

IMPORTANT: Default media type in Quarkus RestEasy is JSON.

// end::update_21_8[]

== XML Marshalling/Unmarshalling

// tag::update_9_8[]
To work with `JAX-B` you need to add a dependency:

[source, bash]
----
./mvnw quarkus:add-extension
  -Dextensions="quarkus-resteasy-jaxb"
----

Then annotated POJOs are converted to XML.

[source, java]
----
@XmlRootElement
public class Message {
}

@GET
@Produces(MediaType.APPLICATION_XML)
public Message hello() {
    return message;
}
----
// end::update_9_8[]

== JAXP

// tag::update_20_1[]
To work with `JAX-P` you need to add a dependency:

[source, bash]
----
./mvnw quarkus:add-extension
  -Dextensions="jaxp"
----

[source, java]
----
final DocumentBuilder dBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
final Document doc = dBuilder.parse(in);
return doc.getDocumentElement().getTextContent();
----
// end::update_20_1[]

== Validator

Quarkus uses https://hibernate.org/validator/[Hibernate Validator, window="_blank"] to validate input/output of REST services and business services using Bean validation spec.

[source, bash]
----
./mvnw quarkus:add-extension
  -Dextensions="io.quarkus:quarkus-hibernate-validator"
----

Annotate POJO objects with validator annotations such as: `@NotNull`, `@Digits`, `@NotBlank`, `@Min`, `@Max`, ...

[source, java]
----
public class Sauce {

    @NotBlank(message = "Name may not be blank")
    private String name;
    @Min(0)
    private long scovilleHeatUnits;

    // getter/setters
}
----

To validate an object use `@Valid` annotation:

[source, java]
----
public Response create(@Valid Sauce sauce) {}
----

TIP: If a validation error is triggered, a violation report is generated and serialized as JSON. If you want to manipulate the output, you need to catch in the code the `ConstraintViolationException` exception.

*Create Your Custom Constraints*

First you need to create the custom annotation:

[source, java]
----
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR,
            PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { NotExpiredValidator.class})
public @interface NotExpired {

    String message() default "Sauce must not be expired";
    Class<?>[] groups() default { };
    Class<? extends Payload>[] payload() default { };

}
----

You need to implement the validator logic in a class that implements `ConstraintValidator`.

[source, java]
----
public class NotExpiredValidator
    implements ConstraintValidator<NotExpired, LocalDate>
    {

    @Override
    public boolean isValid(LocalDate value,
                        ConstraintValidatorContext ctx) {
        if ( value == null ) return true;
        LocalDate today = LocalDate.now();
        return ChronoUnit.YEARS.between(today, value) > 0;
    }
}
----

And use it normally:

[source, java]
----
@NotExpired
@JsonbDateFormat(value = "yyyy-MM-dd")
private LocalDate expired;
----

*Manual Validation*

You can call the validation process manually instead of relaying to `@Valid` by injecting `Validator` class.

[source, java]
----
@Inject
Validator validator;
----

And use it:

[source, java]
----
Set<ConstraintViolation<Sauce>> violations =
            validator.validate(sauce);
----

*Localization*

// tag::update_13_13[]
You can configure the based locale for validation messages.

[source, properties]
----
quarkus.default-locale=ca-ES
# Supported locales resolved by Accept-Language
quarkus.locales=en-US,es-ES,fr-FR, ca_ES
----

[source, properties]
.ValidationMessages_ca_ES.properties
----
pattern.message=No conforme al patro
----

[source, java]
----
@Pattern(regexp = "A.*", message = "{pattern.message}")
private String name;
----
// end::update_13_13[]

// tag::update_15_24[]
Bean Validation can be configured .
The prefix is: `quarkus.hibernate-validator`.

`fail-fast`::
When fail fast is enabled the validation will stop on the first constraint violation detected. (default: `false`)

`method-validation.allow-overriding-parameter-constraints`::
Define whether overriding methods that override constraints should throw an exception. (default: `false`).

`method-validation.allow-parameter-constraints-on-parallel-methods`::
Define whether parallel methods that define constraints should throw an exception. (default: `false`).

`method-validation.allow-multiple-cascaded-validation-on-return-values`::
Define whether more than one constraint on a return value may be marked for cascading validation are allowed. (default: `false`).
// end::update_15_24[]

== Logging

You can configure how Quarkus logs:

[source, properties]
----
quarkus.log.console.enable=true
quarkus.log.console.level=DEBUG
quarkus.log.console.color=false
quarkus.log.category."com.lordofthejars".level=DEBUG
----

Prefix is `quarkus.log`.

`category."<category-name>".level`::
Minimum level category (default: `INFO`)

`level`::
Default minimum level (default: `INFO`)

`console.enabled`::
Console logging enabled (default: `true`)

`console.format`::
Format pattern to use for logging. Default value: +
`%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c{3.}] (%t) %s%e%n`

`console.level`::
Minimum log level (default: `INFO`)

`console.color`::
Allow color rendering (default: `true`)

`file.enable`::
File logging enabled (default: `false`)

`file.format`::
Format pattern to use for logging. Default value: +
`%d{yyyy-MM-dd HH:mm:ss,SSS} %h %N[%i] %-5p [%c{3.}] (%t) %s%e%n`

`file.level`::
Minimum log level (default: `ALL`)

`file.path`::
The path to log file (default: `quarkus.log`)

`file.rotation.max-file-size`::
The maximum file size of the log file

`file.rotation.max-backup-index`::
The maximum number of backups to keep (default: `1`)

`file.rotation.file-suffix`::
Rotating log file suffix.

`file.rotation.rotate-on-boot`::
Indicates rotate logs at bootup (default: `true`)

`file.async`::
Log asynchronously (default: `false`)

<<<

`file.async.queue-length`::
The queue length to use before flushing writing (default: `512`)

`file.async.overflow`::
Action when queue is full (default: `BLOCK`)

`syslog.enable`::
syslog logging is enabled (default: `false`)

`syslog.format`::
The format pattern to use for logging to syslog. Default value: +
`%d{yyyy-MM-dd HH:mm:ss,SSS} %h %N[%i] %-5p [%c{3.}] (%t) %s%e%n`

`syslog.level`::
The minimum log level to write to syslog (default: `ALL`)

`syslog.endpoint`::
The IP address and port of the syslog server (default: `localhost:514`)

`syslog.app-name`::
The app name used when formatting the message in RFC5424 format (default: current process name)

`syslog.hostname`::
The name of the host the messages are being sent from (default: current hostname)

`syslog.facility`::
Priority of the message as defined by RFC-5424 and RFC-3164 (default: `USER_LEVEL`)

`syslog.syslog-type`::
The syslog type of format message (default: `RFC5424`)

`syslog.protocol`::
Protocol used (default: `TCP`)

`syslog.use-counting-framing`::
Message prefixed with the size of the message (default `false`)

`syslog.truncate`::
Message should be truncated (default: `true`)

`syslog.block-on-reconnect`::
Block when attempting to reconnect (default: `true`)

`syslog.async`::
Log asynchronously (default: `false`)

`syslog.async.queue-length`::
The queue length to use before flushing writing (default: `512`)

`syslog.async.overflow`::
Action when queue is full (default: `BLOCK`)

*Gelf ouput*
// tag::update_13_4[]

You can configure the output to be in _GELF_ format instead of plain text.

[source, shell-session]
----
./mvnw quarkus:add-extension
  -Dextensions="quarkus-logging-gelf"
----

`handler.gelf.enabled`::
Enable GELF logging handler (default: `false`)

`handler.gelf.host`::
Hostname/IP of Logstash/Graylof. Prepend `tcp:` for using TCP protocol. (default: `udp:localhost`)

`handler.gelf.port`::
The port. (default: `12201`)

`handler.gelf.version`::
GELF version. (default: `1.1`)

`handler.gelf.extract-stack-trace`::
Post Stack-Trace to StackTrace field. (default: `true`)

`handler.gelf.stack-trace-throwable-reference`::
Gets the cause level to stack trace. `0` is fulls tack trace. (default: `0`)

`handler.gelf.filter-stack-trace`::
Stack-Trace filtering. (default: `false`)

`handler.gelf.timestamp-pattern`::
Java Date pattern. (default: `yyyy-MM-dd HH:mm:ss,SSS`)

`handler.gelf.level`::
Log level `java.util.logging.Level`. (default: `ALL`)

`handler.gelf.facility`::
Name of the facility. (default: `jboss-logmanage`)

`handler.gelf.additional-field.<field>.<subfield>`::
Post additional fields. `quarkus.log.handler.gelf.additional-field.field1.type=String`
// end::update_13_4[]

*JSON output*
// tag::update_12_9[]

You can configure the output to be in _JSON_ format instead of plain text.

[source, shell-session]
----
./mvnw quarkus:add-extension
  -Dextensions="quarkus-logging-json"
----

And the configuration values are prefix with `quarkus.log`:

`json`::
JSON logging is enabled (default: true).

`json.pretty-print`::
JSON output is "pretty-printed" (default: false)

`json.date-format`::
Specify the date format to use (default: the default format)

`json.record-delimiter`::
Record delimiter to add (default: no delimiter)

`json.zone-id`::
The time zone ID

`json.exception-output-type`::
The exception output type: `detailed`, `formatted`, `detailed-and-formatted` (default: `detailed`)

`json.print-details`::
Detailed caller information should be logged (default: false)
// end::update_12_9[]

== Rest Client

Quarkus implements https://github.com/eclipse/microprofile-rest-client[MicroProfile Rest Client, window="_blank"] spec:

[source, bash]
----
./mvnw quarkus:add-extension
  -Dextensions="quarkus-rest-client"
----

To get content from http://worldclockapi.com/api/json/cet/now you need to create a service interface:

[source, java]
----
@Path("/api")
@RegisterRestClient
public interface WorldClockService {

    @GET @Path("/json/cet/now")
    @Produces(MediaType.APPLICATION_JSON)
    WorldClock getNow();

    @GET
    @Path("/json/{where}/now")
    @Produces(MediaType.APPLICATION_JSON)
    WorldClock getSauce(@BeanParam
                    WorldClockOptions worldClockOptions);

}
----

[source, java]
----
public class WorldClockOptions {
    @HeaderParam("Authorization")
    String auth;

    @PathParam("where")
    String where;
}
----

And configure the hostname at `application.properties`:

[source, properties]
----
org.acme.quickstart.WorldClockService/mp-rest/url=
        http://worldclockapi.com
----

Injecting the client:

[source, java]
----
@RestClient
WorldClockService worldClockService;
----

// tag::update_1_1[]
If invokation happens within JAX-RS, you can propagate headers from incoming to outgoing by using next property.

[source, properties]
----
org.eclipse.microprofile.rest.client.propagateHeaders=
            Authorization,MyCustomHeader
----
// end::update_1_1[]

TIP: You can still use the JAX-RS client without any problem `ClientBuilder.newClient().target(...)`

*Adding headers*

You can customize the headers passed by implementing MicroProfile `ClientHeadersFactory` annotation:

[source, java]
----
@RegisterForReflection
public class BaggageHeadersFactory
                implements ClientHeadersFactory {
    @Override
    public MultivaluedMap<String, String> update(
        MultivaluedMap<String, String> incomingHeaders,
        MultivaluedMap<String, String> outgoingHeaders) {}
}
----

And registering it in the client using `RegisterClientHeaders` annotation.

[source, java]
----
@RegisterClientHeaders(BaggageHeadersFactory.class)
@RegisterRestClient
public interface WorldClockService {}
----

Or statically set:

[source, java]
----
@GET
@ClientHeaderParam(name="X-Log-Level", value="ERROR")
Response getNow();
----

*Asynchronous*

A method on client interface can return a `CompletionStage` class to be executed asynchronously.

[source, java]
----
@GET @Path("/json/cet/now")
@Produces(MediaType.APPLICATION_JSON)
CompletionStage<WorldClock> getNow();
----

*Reactive*

// tag::update_14_15[]
Rest Client also integrates with reactive library named Mutiny.
To start using it you need to add the `quarkus-rest-client-mutiny`.

After that, a methodon a client interface can return a `io.smallrye.mutiny.Uni` instance.

[source, java]
----
@GET @Path("/json/cet/now")
@Produces(MediaType.APPLICATION_JSON)
Uni<WorldClock> getNow();
----
// end::update_14_15[]

*Multipart*

// tag::update_10_10[]
It is really easy to send multipart form-data with Rest Client.

[source, xml]
----
<dependency>
    <groupId>org.jboss.resteasy</groupId>
    <artifactId>resteasy-multipart-provider</artifactId>
</dependency>
----

The model object:

[source, java]
----
import java.io.InputStream;

import javax.ws.rs.FormParam;
import javax.ws.rs.core.MediaType;

import 
    org.jboss.resteasy.annotations.providers.multipart.PartType;

public class MultipartBody {

    @FormParam("file")
    @PartType(MediaType.APPLICATION_OCTET_STREAM)
    private InputStream file;

    @FormParam("fileName")
    @PartType(MediaType.TEXT_PLAIN)
    private String name;

    // getter/setters
}
----

And the Rest client interface:

[source, java]
----
import 
    org.jboss.resteasy.annotations.providers.multipart.MultipartForm;

@Path("/echo")
@RegisterRestClient
public interface MultipartService {

    @POST
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    @Produces(MediaType.TEXT_PLAIN)
    String sendMultipartData(@MultipartForm 
                        MultipartBody data);

}
----
// end::update_10_10[]

// tag::update_11_4[]
*SSL*

You can configure Rest Client key stores.

[source, properties]
----
org.acme.quickstart.WorldClockService/mp-rest/trustStore=
    classpath:/store.jks
org.acme.quickstart.WorldClockService/mp-rest/trustStorePassword=
    supersecret
----

Possible configuration properties:

`%s/mp-rest/trustStore`::
Trust store location defined with `classpath:` or `file:` prefix.

`%s/mp-rest/trustStorePassword`::
Trust store password.

`%s/mp-rest/trustStoreType`::
Trust store type (default: `JKS`)

`%s/mp-rest/hostnameVerifier`::
Custom hostname verifier class name. To disable SSL verification you can use `io.quarkus.restclient.NoopHostnameVerifier`.

`%s/mp-rest/keyStore`::
Key store location defined with `classpath:` or `file:` prefix.

`%s/mp-rest/keyStorePassword`::
Key store password.

`%s/mp-rest/keyStoreType`::
Key store type (default: `JKS`)
// end::update_11_4[]

// tag::update_11_5[]
*Timeout* 

You can define the timeout of the Rest Client:

[source, properties]
----
org.acme.quickstart.WorldClockService/mp-rest/connectTimeout=
    1000
org.acme.quickstart.WorldClockService/mp-rest/readTimeout=
    2000
----
// end::update_11_5[]

*Instantiate client programmatically*

// tag::update_20_4[]
[source, java]
----
MovieReviewService reviewSvc = RestClientBuilder.newBuilder()
            .baseUri(apiUri)
            .build(WorldClockService.class);
----
// end::update_20_4[]

== Testing

Quarkus archetype adds test dependencies with JUnit 5 and Rest-Assured library to test REST endpoints.

[source, java]
----
@QuarkusTest
public class GreetingResourceTest {

    @Test
    public void testHelloEndpoint() {
        given()
          .when().get("/hello")
          .then()
             .statusCode(200)
             .body(is("hello"));
    }
}
----

Test port can be set in `quarkus.http.test-port` property.
Timeout can be set in `quarkus.http.test-timeout` property.

You can also inject the URL where Quarkus is started:

[source, java]
----
@TestHTTPResource("index.html")
URL url;
----

// tag::update_18_9[]
[source, java]
----
@TestHTTPEndpoint(GreetingResource.class)
@TestHTTPResource
URL url;
----

[source, java]
----
@QuarkusTest
@TestHTTPEndpoint(GreetingResource.class)
public class GreetingResourceTest {
    @Test
    public void testHelloEndpoint() {
        given()
          .when().get()
          .then()
             .statusCode(200)
             .body(is("hello"));
    }
}
----

Root path is calculated automatically, not necessary to explicitly set.
// end::update_18_9[]

// tag::update_20_3[]
If you want any changes made to be rolled back at the end ofthe test you can use the `io.quarkus.test.TestTransaction` annotation.
// end::update_20_3[]

*QuarkusTestProfile*

// tag::update_18_5[]
You can define for each Test class a different configuration options.

IMPORTANT: This implies that the Quarkus service is restarted.

[source, java]
----
public class MyProfile implements io.quarkus.test.junit.QuarkusTestProfile {
    
    @Override
    public Map<String, String> getConfigOverrides() {
        return Map.of("greetings.message", "This is a Test");
    }

    @Override
    public String getConfigProfile() {
        return "my-test-profile";
    }
}

@QuarkusTest
@TestProfile(MyProfile.class)
public class MyTestClass {
}
----
// end::update_18_5[]

*Quarkus Test Resource*

// tag::update_4_2[]
You can execute some logic before the first test run (`start`) and execute some logic at the end of the test suite (`stop`).

<<<

You need to create a class implementing `QuarkusTestResourceLifecycleManager` interface and register it in the test via `@QuarkusTestResource` annotation.

[source, java]
----
public class MyCustomTestResource
    implements QuarkusTestResourceLifecycleManager {

    @Override
    public Map<String, String> start() {
        // return system properties that
        // should be set for the running test
        return Collections.emptyMap();
    }

    @Override
    public void stop() {
    }

    // optional
    @Override
    public void inject(Object testInstance) {
    }

    // optional
    @Override
    public int order() {
        return 0;
    }
}
----

IMPORTANT: Returning new system properties implies running parallel tests in different JVMs.

And the usage:

[source, java]
----
@QuarkusTestResource(MyCustomTestResource.class)
public class MyTest {
}
----

*Testing Callbacks*

//tag::update_20_6[]
You can enrich *all* your `@QuarkusTest` classes by implementing the following callback interfaces:

* `io.quarkus.test.junit.callback.QuarkusTestBeforeClassCallback`
* `io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback`
* `io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback`
* `io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback`

[source, java]
----
public class SimpleAnnotationCheckerBeforeClassCallback implements QuarkusTestBeforeClassCallback {
   @Override
    public void beforeClass(Class<?> testClass) {
    }
}
----

And needs to be registered as Java SPI:

[source]
.META-INF/services/io.quarkus.test.junit.callback.QuarkusTestBeforeClassCallback
----
io.quarkus.it.main.SimpleAnnotationCheckerBeforeClassCallback
----
//end::update_20_6[]

// end::update_4_2[]
*Mocking*

If you need to provide an alternative implementation of a service (for testing purposes) you can do it by using CDI `@Alternative` annotation using it in the test service placed at `src/test/java`:

[source, java]
----
@Alternative
@Priority(1)
@ApplicationScoped
public class MockExternalService extends ExternalService {}
----

IMPORTANT: This does not work when using native image testing.

// tag::update_3_6[]
A stereotype annotation `io.quarkus.test.Mock` is provided declaring `@Alternative`, `@Priority(1)` and `@Dependent`.
// end::update_3_6[]

*Mockito*

// tag::update_15_12[]
Instead of creating stubs, you can also create mocks of your services with mockito.
Add the following dependency `io.quarkus:quarkus-junit5-mockito`:

[source, java]
----
@InjectMock
GreetingService greetingService;

@BeforeEach
public void setup() {
    Mockito.when(greetingService.greet()).thenReturn("Hi");
}

@Path("/hello")
public class ExampleResource {

    @Inject
    GreetingService greetingService;
}
----

Mock is automatically injected and only valid for the defined test class.

// tag::update_16_25[]
Also `spy` is supported:

[source, java]
----
@InjectSpy
GreetingService greetingService;

Mockito.verify(greetingService, Mockito.times(1)).greet();
----
// end::update_16_25[]

*REST Client*

To Mock REST Client, you need to define the interface with `@ApplicationScope`:

[source, java]
----
@ApplicationScoped
@RegisterRestClient
public interface GreetingService {
}

@InjectMock
@RestClient
GreetingService greetingService;

Mockito.when(greetingService.hello()).thenReturn("hello from mockito");
----

// end::update_15_12[]

*Interceptors*
// tag::update_5_5[]

Tests are actually full CDI beans, so you can apply CDI interceptors:

[source, java]
----
@QuarkusTest
@Stereotype
@Transactional
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface TransactionalQuarkusTest {
}

@TransactionalQuarkusTest
public class TestStereotypeTestCase {}
----
// end::update_5_5[]

*Test Coverage*
// tag::update_6_3[]
Due the nature of Quarkus to calculate correctly the coverage information with JaCoCo, you might need offline instrumentation.
I recommend reading https://quarkus.io/guides/tests-with-coverage-guide[this document, window="_blank"] to understand how JaCoCo and Quarkus works and how you can configure JaCoCo to get correct data.
// end::update_6_3[]

*Native Testing*

To test native executables annotate the test with `@NativeImageTest`.
