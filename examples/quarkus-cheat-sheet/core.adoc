== Getting Started

Quarkus comes with a Maven archetype to scaffold a very simple starting project.

[source, bash, subs=attributes+]
----
mvn io.quarkus:quarkus-maven-plugin:{version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=getting-started \
    -DclassName="org.acme.quickstart.GreetingResource" \
    -Dpath="/hello"
----

This creates a simple JAX-RS resource called `GreetingResource`.

[source, java]
----
@Path("/hello")
public class GreetingResource {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "hello";
    }
}
----

== Extensions

Quarkus comes with extensions to integrate with some libraries such as JSON-B, Camel or MicroProfile spec.
To list all available extensions just run:

[source, bash]
----
./mvnw quarkus:list-extensions
----

// tag::update_2_4[]
TIP: You can use `-DsearchPattern=panache` to filter out all extensions except the ones matching the expression.
// end::update_2_4[]

And to register the extensions into build tool:

[source, bash]
----
./mvnw quarkus:add-extension -Dextensions=""
----

TIP: `extensions` property supports CSV format to register more than one extension at once.

== Application Lifecycle
// tag::update_1_3[]
You can be notified when the application starts/stops by observing `StartupEvent` and `ShutdownEvent` events.

[source, java]
----
@ApplicationScoped
public class ApplicationLifecycle {
    void onStart(@Observes StartupEvent event) {}
    void onStop(@Observes ShutdownEvent event) {}
}
----
// end::update_1_3[]

== Adding Configuration Parameters

To add configuration to your application, Quarkus relies on https://github.com/eclipse/microprofile-config[MicroProfile Config, window="_blank"] spec.

[source, java]
----
@ConfigProperty(name = "greetings.message")
String message;

@ConfigProperty(name = "greetings.message", 
                defaultValue = "Hello")
String messageWithDefault;

@ConfigProperty(name = "greetings.message")
Optional<String> optionalMessage;
----

Properties can be set as:

* Environment variables (`GREETINGS_MESSAGE`).
* System properties (`-Dgreetings.message`).
* Resources `src/main/resources/application.properties`.
* External config directory under the current working directory: `config/application.properties`.

[source, properties]
----
greetings.message = Hello World
----

// tag::update_2_7[]
TIP: `Array`, `List` and `Set` are supported. The delimiter is comma (`,`) char and `\` is the escape char.
// end::update_2_7[]

// tag::update_2_9[]
*Configuration Profiles*

Quarkus allow you to have multiple configuration in the same file (`application.properties`).

The syntax for this is `%{profile}.config.key=value`.

[source, properties]
----
quarkus.http.port=9090
%dev.quarkus.http.port=8181
----

HTTP port will be 9090, unless the 'dev' profile is active.

Default profiles are:

* `dev`: Activated when in development mode (`quarkus:dev`).
* `test`: Activated when running tests.
* `prod`: The default profile when not running in development or test mode

You can create custom profile names by enabling the profile either setting `quarkus.profile` system property or `QUARKUS_PROFILE` environment variable.

[source, properties]
----
quarkus.http.port=9090
%staging.quarkus.http.port=9999
----

And enable it `quarkus.profile=staging`.
// end::update_2_9[]

// tag::update_6_7[]
You can also set it in the build tool:

[source, xml]
----
<groupId>org.apache.maven.plugins</groupId>
<artifactId>maven-surefire-plugin</artifactId>
<version>${surefire-plugin.version}</version>
<configuration>
    <systemPropertyVariables>
        <quarkus.test.profile>foo</quarkus.test.profile>
        <buildDirectory>${project.build.directory}
        </buildDirectory>
    </systemPropertyVariables>
</configuration>
----

TIP: Same for `maven-failsafe-plugin`.

[source, groovy]
----
test {
    useJUnitPlatform()
    systemProperty "quarkus.test.profile", "foo"
}
----
// end::update_6_7[]

// tag::update_9_1[]
*@ConfigProperties*

As an alternative to injecting multiple related configuration values, you can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group properties.

[source, java]
----
@ConfigProperties(prefix = "greeting")
public class GreetingConfiguration {
    private String message;
    // getter/setter
}
----

This class maps `greeting.message` property defined in `application.properties`.

You can inject this class by using CDI `@Inject GreetingConfiguration greeting;`.

Also you can use an interface approach:

[source, java]
----
@ConfigProperties(prefix = "greeting")
public interface GreetingConfiguration {
    
    @ConfigProperty(name = "message")
    String message();
    String getSuffix();
----

If property does not follow getter/setter naming convention you need to use `org.eclipse.microprofile.config.inject.ConfigProperty` to set it.

Nested objects are also supporte:

[source, java]
----
@ConfigProperties(prefix = "greeting")
public class GreetingConfiguration {
    public String message;
    public HiddenConfig hidden;
    
    public static class HiddenConfig {
        public List<String> recipients;
    }
}
----

And an `application.properties` mapping previous class:

[source, properties]
----
greeting.message = hello
greeting.hidden.recipients=Jane,John
----

Bean Validation is also supported so properties are validated at startup time, for example `@Size(min = 20) public String message;`.

*TIP*:`prefix` attribute is not mandatory. If not provided, attribute is determined by class name (ie `GreeetingConfiguration` is translated to `greeting` or `GreetingExtraConfiguration` to `greeting-extra`). The suffix of the class is always removed.
// end::update_9_1[]

// tag::update_2_6[]

<<<

*Custom Loader*

You can implement your own `ConfigSource` to load configuration from different places than the default ones provided by Quarkus. 
For example, database, custom XML, REST Endpoints, ...

You need to create a new class and implement `ConfigSource` interface:

[source, java]
----
package com.acme.config;
public class InMemoryConfig implements ConfigSource {
    
    private Map<String, String> prop = new HashMap<>();
    
    public InMemoryConfig() {
        // Init properties
    }

    @Override
    public int getOrdinal() {
        // The highest ordinal takes precedence
        return 900;
    }

    @Override
    public Map<String, String> getProperties() {
        return prop;
    }

    @Override
    public String getValue(String propertyName) {
        return prop.get(propertyName);
    }

    @Override
    public String getName() {
        return "MemoryConfigSource";
    }
}
----

Then you need to register the `ConfigSource` as Java service. 
Create a file `/META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource` with next content:

[source]
----
com.acme.config.InMemoryConfig
----
// end::update_2_6[]

// tag::update_2_8[]
*Custom Converters*

You can implement your own conversion types from String.
Implement `org.eclipse.microprofile.config.spi.Converter` interface:

[source, java]
----
@Priority(DEFAULT_QUARKUS_CONVERTER_PRIORITY + 100)
public class CustomInstantConverter 
    implements Converter<Instant> {

    @Override
    public Instant convert(String value) {
        if ("now".equals(value.trim())) {
            return Instant.now();
        }
        return Instant.parse(value);
    }
}
----

`@Priority` annotation is used to override the default `InstantConverter`.

Then you need to register the `Converter` as Java service. 
Create a file `/META-INF/services/org.eclipse.microprofile.config.spi.Converter` with next content:

[source]
----
com.acme.config.CustomInstantConverter
----
// end::update_2_8[]

== Custom Context Path
// tag::update_6_2[]
By default Undertow will serve content from under the root context. 
If you want to change this you can use the `quarkus.servlet.context-path` config key to set the context path.
// end::update_6_2[]

== Injection

Quarkus is based on CDI 2.0 to implement injection of code.
It is not fully supported and only a subset of the https://quarkus.io/guides/cdi-reference[specification is implemented, window="_blank"].

[source, java]
----
@ApplicationScoped
public class GreetingService {

    public String message(String message) {
        return message.toUpperCase();
    }
}
----

Scope annotation is mandatory to make the bean discoverable.

[source, java]
----
@Inject
GreetingService greetingService;
----

IMPORTANT: Quarkus is designed with Substrate VM in mind. For this reason, we encourage you to use _package-private_ scope instead of _private_.

<<<

*Produces*

// tag::update_5_4[]
You can also create a factory of an object by using `@javax.enterprise.inject.Produces` annotation.

[source, java]
----
@Produces
@ApplicationScoped
Message message() {
    Message m = new Message();
    m.setMsn("Hello");
    return m;
}

@Inject
Message msg;
----

*Qualifiers*

You can use qualifiers to return different implementations of the same interface or to customize the configuration of the bean.

[source, java]
----
@Qualifier
@Retention(RUNTIME)
@Target({TYPE, METHOD, FIELD, PARAMETER})
public @interface Quote {
    @Nonbinding String value();
}

@Produces
@Quote("")
Message message(InjectionPoint msg) {
    Message m = new Message();
    m.setMsn(
        msg.getAnnotated()
        .getAnnotation(Quote.class)
        .value()
    );

    return m;
}

@Inject
@Quote("Aloha Beach")
Message message;
----
// end::update_5_4[]

// tag::update_7_1[]
*TIP*

Quarkus breaks the CDI spec by allowing you to inject qualified beans without using `@Inject` annotation.

[source, java]
----
@Quote("Aloha Beach")
Message message;
----
// end::update_7_1[]

== JSON Marshalling/Unmarshalling

To work with `JSON-B` you need to add a dependency:

[source, bash]
----
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-resteasy-jsonb"
----

Any POJO is marshaled/unmarshalled automatically.

[source, java]
----
public class Sauce {
    private String name;
    private long scovilleHeatUnits;

    // getter/setters
}
----

JSON equivalent:

[source, json]
----
{
	"name":"Blair's Ultra Death",
	"scovilleHeatUnits": 1100000
}
----

In a `POST` endpoint example:

[source, java]
----
@POST
@Consumes(MediaType.APPLICATION_JSON)
public Response create(Sauce sauce) {
    // Create Sauce
    return Response.created(URI.create(sauce.getId()))
            .build();
}
----

// tag::update_6_1[]
To work with `Jackson` you need to add:

[source, bash]
----
./mvnw quarkus:add-extension 
  -Dextensions="quarkus-resteasy-jackson"
----

If you don't want to use the default `ObjectMapper` you can customize it by:

[source, java]
----
@ApplicationScoped
public class CustomObjectMapperConfig {
    @Singleton
    @Produces
    public ObjectMapper objectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();
        // perform configuration
        return objectMapper;
    }
}
----
// end::update_6_1[]

== XML Marshalling/Unmarshalling

// tag::update_9_8[]
To work with `JAX-B` you need to add a dependency:

[source, bash]
----
./mvnw quarkus:add-extension 
  -Dextensions="quarkus-resteasy-jaxb"
----

Then annotated POJOs are converted to XML.

[source, java]
----
@XmlRootElement
public class Message {
}

 @GET
@Produces(MediaType.APPLICATION_XML)
public Message hello() {
    return message;
}
----
// end::update_9_8[]

== Validator

Quarkus uses https://hibernate.org/validator/[Hibernate Validator, window="_blank"] to validate input/output of REST services and business services using Bean validation spec.

[source, bash]
----
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-hibernate-validator"
----

Annotate POJO objects with validator annotations such as: `@NotNull`, `@Digits`, `@NotBlank`, `@Min`, `@Max`, ...

[source, java]
----
public class Sauce {

    @NotBlank(message = "Name may not be blank")
    private String name;
    @Min(0)
    private long scovilleHeatUnits;

    // getter/setters
}
----

To validate an object use `@Valid` annotation:

[source, java]
----
public Response create(@Valid Sauce sauce) {}
----

TIP: If a validation error is triggered, a violation report is generated and serialized as JSON. If you want to manipulate the output, you need to catch in the code the `ConstraintViolationException` exception.

*Create Your Custom Constraints*

First you need to create the custom annotation:

[source, java]
----
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, 
            PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { NotExpiredValidator.class})
public @interface NotExpired {

    String message() default "Sauce must not be expired";
    Class<?>[] groups() default { };
    Class<? extends Payload>[] payload() default { };

}
----

You need to implement the validator logic in a class that implements `ConstraintValidator`. 

[source, java]
----
public class NotExpiredValidator 
    implements ConstraintValidator<NotExpired, LocalDate> 
    {

    @Override
    public boolean isValid(LocalDate value, 
                        ConstraintValidatorContext ctx) {
        if ( value == null ) return true;
        LocalDate today = LocalDate.now();
        return ChronoUnit.YEARS.between(today, value) > 0;
    }
}
----

And use it normally:

[source, java]
----
@NotExpired
@JsonbDateFormat(value = "yyyy-MM-dd")
private LocalDate expired;
----

*Manual Validation*

You can call the validation process manually instead of relaying to `@Valid` by injecting `Validator` class.

[source, java]
----
@Inject
Validator validator;
----

And use it:

[source, java]
----
Set<ConstraintViolation<Sauce>> violations = 
            validator.validate(sauce);
----

== Logging

You can configure how Quarkus logs:

[source, properties]
----
quarkus.log.console.enable=true
quarkus.log.console.level=DEBUG
quarkus.log.console.color=false
quarkus.log.category."com.lordofthejars".level=DEBUG
----

Prefix is `quarkus.log`.

|===	
| Property | Default | Description
a|`category."<category-name>".level`
a|`INFO`
a|Minimum level category.

a|`level`
a|`INFO`
a|Default minimum level.

a|`console.enable`
a|`true`
a|Console logging enabled.

a|`console.format`
a|`%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c{3.}] (%t) %s%e%n`
a|Format pattern to use for logging.

a|`console.level`
a|`INFO`
a|Minimum log level.

a|`console.color`
a|`INFO`
a|Allow color rendering.

a|`file.enable`
a|`false`
a|File logging enabled.

a|`file.format`
a|`%d{yyyy-MM-dd HH:mm:ss,SSS} %h %N[%i] %-5p [%c{3.}] (%t) %s%e%n`
a|Format pattern to use for logging.

a|`file.level`
a|`ALL`
a|Minimum log level.

a|`file.path`
a|`quarkus.log`
a|The path to log file.

a|`file.rotation.max-file-size`
a|
a|The maximum file size of the log file.

a|`file.rotation.max-backup-index`
a|`1`
|The maximum number of backups to keep.

a|`file.rotation.file-suffix`
a|
|Rotating log file suffix.

a|`file.rotation.rotate-on-boot`
a|`true`
|Indicates rotate logs at bootup.

a|`file.async`
a|`false`
|Log asynchronously.

a|`file.async.queue-length`
a|`512`
|The queue length to use before flushing writing.

a|`file.async.overflow`
a|`BLOCK`
|Action when queue is full.

a|`syslog.enable`
a|`false`
|syslog logging is enabled.

a|`syslog.format`
a|`%d{yyyy-MM-dd HH:mm:ss,SSS} %h %N[%i] %-5p [%c{3.}] (%t) %s%e%n`
|The format pattern to use for logging to syslog.

a|`syslog.level`
a|`ALL`
|The minimum log level to write to syslog.

a|`syslog.endpoint`
a|`localhost:514`
|The IP address and port of the syslog server.

a|`syslog.app-name`
a|Current process name.
|The app name used when formatting the message in RFC5424 format.

a|`syslog.hostname`
a|Current hostname.
|The name of the host the messages are being sent from.

a|`syslog.facility`
a|`USER_LEVEL`
|Priority of the message as defined by RFC-5424 and RFC-3164.

a|`syslog.syslog-type`
a|`RFC5424`
|The syslog type of format message.

a|`syslog.protocol`
a|`TCP`
|Protocol used.

a|`syslog.use-counting-framing`
a|`false`
|Message prefixed with the size of the message.

a|`syslog.truncate`
a|`true`
|Message should be truncated.

a|`syslog.block-on-reconnect`
a|`true`
|Block when attempting to reconnect.

a|`syslog.async`
a|`false`
|Log asynchronously.

a|`syslog.async.queue-length`
a|`512`
|The queue length to use before flushing writing.

a|`syslog.async.overflow`
a|`BLOCK`
|Action when queue is full.
|===

== Rest Client

Quarkus implements https://github.com/eclipse/microprofile-rest-client[MicroProfile Rest Client, window="_blank"] spec:

[source, bash]
----
./mvnw quarkus:add-extension 
  -Dextensions="io.quarkus:quarkus-rest-client"
----

To get content from http://worldclockapi.com/api/json/cet/now you need to create a service interface:

[source, java]
----
@Path("/api")
@RegisterRestClient
public interface WorldClockService {

    @GET @Path("/json/cet/now")
    @Produces(MediaType.APPLICATION_JSON) 
    WorldClock getNow();

    @GET
    @Path("/json/{where}/now")
    @Produces(MediaType.APPLICATION_JSON) 
    WorldClock getSauce(@BeanParam 
                    WorldClockOptions worldClockOptions);

}
----

[source, java]
----
public class WorldClockOptions {
    @HeaderParam("Authorization")
    String auth;

    @PathParam("where")
    String where;   
}
----

And configure the hostname at `application.properties`:

[source, properties]
----
org.acme.quickstart.WorldClockService/mp-rest/url=
        http://worldclockapi.com
----

Injecting the client:

[source, java]
----
@RestClient
WorldClockService worldClockService;
----

// tag::update_1_1[]
If invokation happens within JAX-RS, you can propagate headers from incoming to outgoing by using next property.

[source, properties]
----
org.eclipse.microprofile.rest.client.propagateHeaders=
            Authorization,MyCustomHeader
----
// end::update_1_1[]

TIP: You can still use the JAX-RS client without any problem `ClientBuilder.newClient().target(...)`

*Adding headers*

You can customize the headers passed by implementing MicroProfile `ClientHeadersFactory` annotation:

[source, java]
----
@RegisterForReflection
public class BaggageHeadersFactory 
                implements ClientHeadersFactory {
    @Override
    public MultivaluedMap<String, String> update(
        MultivaluedMap<String, String> incomingHeaders, 
        MultivaluedMap<String, String> outgoingHeaders) {}
}
----

And registering it in the client using `RegisterClientHeaders` annotation.

[source, java]
----
@RegisterClientHeaders(BaggageHeadersFactory.class)
@RegisterRestClient
public interface WorldClockService {}
----

Or statically set:

[source, java]
----
@GET
@ClientHeaderParam(name="X-Log-Level", value="ERROR")
Response getNow();
----

*Asynchronous*

A method on client interface can return a `CompletionStage` class to be executed asynchronously.

[source, java]
----
@GET @Path("/json/cet/now")
@Produces(MediaType.APPLICATION_JSON) 
CompletionStage<WorldClock> getNow();
----

== Testing

Quarkus archetype adds test dependencies with JUnit 5 and Rest-Assured library to test REST endpoints.

[source, java]
----
@QuarkusTest
public class GreetingResourceTest {

    @Test
    public void testHelloEndpoint() {
        given()
          .when().get("/hello")
          .then()
             .statusCode(200)
             .body(is("hello"));
    }
}
----
    
Test port can be set in `quarkus.http.test-port` property.

You can also inject the URL where Quarkus is started:

[source, java]
----
@TestHTTPResource("index.html") 
URL url;
----

*Quarkus Test Resource*

// tag::update_4_2[]
You can execute some logic before the first test run (`start`) and execute some logic at the end of the test suite (`stop`).

You need to create a class implementing `QuarkusTestResourceLifecycleManager` interface and register it in the test via `@QuarkusTestResource` annotation.

[source, java]
----
public class MyCustomTestResource 
    implements QuarkusTestResourceLifecycleManager {

    @Override
    public Map<String, String> start() {
        // return system properties that 
        // should be set for the running test
        return Collections.emptyMap();
    }

    @Override
    public void stop() {
    }

    // optional
    @Override
    public void inject(Object testInstance) {
    }

    // optional
    @Override
    public int order() {
        return 0;
    }
}
----

IMPORTANT: Returning new system properties implies running parallel tests in different JVMs.

And the usage:

[source, java]
----
@QuarkusTestResource(MyCustomTestResource.class)
public class MyTest {
}
----

// end::update_4_2[]
*Mocking* 

If you need to provide an alternative implementation of a service (for testing purposes) you can do it by using CDI `@Alternative` annotation using it in the test service placed at `src/test/java`:

[source, java]
----
@Alternative
@Priority(1)
@ApplicationScoped
public class MockExternalService extends ExternalService {}
----

IMPORTANT: This does not work when using native image testing.

// tag::update_3_6[]
A stereotype annotation `io.quarkus.test.Mock` is provided declaring `@Alternative`, `@Priority(1)` and `@Dependent`.
// end::update_3_6[]

*Interceptors*
// tag::update_5_5[]

Tests are actually full CDI beans, so you can apply CDI interceptors:

[source, java]
----
@QuarkusTest
@Stereotype
@Transactional
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface TransactionalQuarkusTest {
}

@TransactionalQuarkusTest
public class TestStereotypeTestCase {}
----
// end::update_5_5[]

*Test Coverage*
// tag::update_6_3[]
Due the nature of Quarkus to calculate correctly the coverage information with JaCoCo, you might need offline instrumentation.
I recommend reading https://quarkus.io/guides/tests-with-coverage-guide[this document, window="_blank"] to understand how JaCoCo and Quarkus works and how you can configure JaCoCo to get correct data.
// end::update_6_3[]

*Native Testing*

To test native executables annotate the test with `@SubstrateTest`.
